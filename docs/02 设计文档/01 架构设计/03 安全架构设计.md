# 安全架构设计

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档版本 | V1.0 |
| 文档状态 | 已完成 |
| 创建日期 | 2026-02-28 |
| 最后更新 | 2026-02-28 |

---

## 1. 安全架构概述

### 1.1 安全设计目标

RedInk 作为公文编写软件，安全性是首要考量。核心安全目标：

| 目标 | 说明 | 优先级 |
|------|------|--------|
| 数据隔离 | 公网/私域环境严格隔离，防止敏感数据外泄 | P0 |
| 传输安全 | 公网通信全程加密，防止中间人攻击 | P0 |
| 存储安全 | 本地敏感数据加密存储，防止未授权访问 | P1 |
| 访问控制 | API密钥安全管理，防止凭证泄露 | P1 |
| 审计追踪 | 关键操作可追溯，支持安全审计 | P2 |

### 1.2 威胁模型

```
┌─────────────────────────────────────────────────────────────────────┐
│                          威胁分析                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────┐                    ┌─────────────────┐        │
│  │   外部威胁       │                    │   内部威胁       │        │
│  │                 │                    │                 │        │
│  │  • 网络窃听     │                    │  • 误操作泄露   │        │
│  │  • 中间人攻击   │                    │  • 环境误切换   │        │
│  │  • API密钥窃取  │                    │  • 敏感内容外发 │        │
│  │  • 恶意软件     │                    │  • 不当共享     │        │
│  └─────────────────┘                    └─────────────────┘        │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                     防护策略                                 │   │
│  │                                                             │   │
│  │  TLS加密  |  公私隔离  |  敏感检测  |  审计日志  |  加密存储 │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. 公私隔离机制设计

### 2.1 隔离架构

公私隔离是 RedInk 的核心安全特性，从以下层面实现隔离：

```
┌─────────────────────────────────────────────────────────────────────┐
│                         公私隔离架构                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────┐    ┌─────────────────────────┐        │
│  │      公网环境 (蓝)       │    │      私域环境 (绿)       │        │
│  │      #1890FF            │    │      #52C41A            │        │
│  ├─────────────────────────┤    ├─────────────────────────┤        │
│  │                         │    │                         │        │
│  │  界面层                  │    │  界面层                  │        │
│  │  • 蓝色主题             │    │  • 绿色主题             │        │
│  │  • 云朵图标             │    │  • 盾牌图标             │        │
│  │  • "公网环境"标识       │    │  • "私域安全"标识       │        │
│  │                         │    │                         │        │
│  │  网络层                  │    │  网络层                  │        │
│  │  • 允许公网请求          │    │  • 仅限本地请求         │        │
│  │  • TLS加密传输          │    │  • localhost/内网       │        │
│  │                         │    │                         │        │
│  │  AI服务                  │    │  AI服务                  │        │
│  │  • OpenAI/Claude/国产   │    │  • Ollama/LM Studio    │        │
│  │  • 云端处理             │    │  • 本地处理             │        │
│  │                         │    │                         │        │
│  │  数据流向                │    │  数据流向                │        │
│  │  • 加密上传至云端       │    │  • 完全本地存储         │        │
│  │  • 可能被记录           │    │  • 不经过网络           │        │
│  └─────────────────────────┘    └─────────────────────────┘        │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    环境切换防护                              │   │
│  │                                                             │   │
│  │  私域 → 公网：需二次确认 + 安全警告                          │   │
│  │  公网 → 私域：直接切换，无警告                               │   │
│  │                                                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 网络隔离实现

```typescript
/**
 * 网络请求拦截器 - 实现私域环境网络隔离
 */
class NetworkGuard {
  private envManager: EnvironmentManager;
  
  /**
   * 拦截并验证所有外发请求
   */
  interceptRequest(config: RequestConfig): RequestConfig | never {
    const env = this.envManager.getCurrentEnvironment();
    
    // 私域环境下，阻止所有公网请求
    if (env.type === 'private') {
      const url = new URL(config.url, config.baseURL);
      
      if (!this.isLocalRequest(url)) {
        throw new SecurityError(
          '私域环境禁止访问公网',
          'NETWORK_BLOCKED',
          { url: url.href }
        );
      }
    }
    
    return config;
  }
  
  /**
   * 判断是否为本地请求
   */
  private isLocalRequest(url: URL): boolean {
    const localHosts = [
      'localhost',
      '127.0.0.1',
      '0.0.0.0',
      '::1'
    ];
    
    // 检查是否为本地地址
    if (localHosts.includes(url.hostname)) {
      return true;
    }
    
    // 检查是否为内网地址
    if (this.isPrivateIP(url.hostname)) {
      return true;
    }
    
    return false;
  }
  
  /**
   * 判断是否为私有IP地址
   */
  private isPrivateIP(ip: string): boolean {
    // 10.0.0.0/8
    if (ip.startsWith('10.')) return true;
    
    // 172.16.0.0/12
    if (ip.startsWith('172.')) {
      const second = parseInt(ip.split('.')[1]);
      if (second >= 16 && second <= 31) return true;
    }
    
    // 192.168.0.0/16
    if (ip.startsWith('192.168.')) return true;
    
    return false;
  }
}
```

### 2.3 环境切换安全确认

```typescript
/**
 * 环境切换确认对话框配置
 */
interface SwitchConfirmConfig {
  title: string;
  content: string;
  confirmText: string;
  cancelText: string;
  type: 'warning' | 'info';
}

/**
 * 私域到公网切换的确认配置
 */
const PRIVATE_TO_PUBLIC_CONFIRM: SwitchConfirmConfig = {
  title: '切换到公网环境',
  content: `
    您正在从私域环境切换到公网环境，请注意：
    
    1. 公网环境下，您的输入内容将通过互联网发送至云端AI服务
    2. 云端服务可能会记录您的请求内容
    3. 请确保当前文档及后续输入不包含敏感信息
    
    如果您的文档包含以下内容，建议继续使用私域环境：
    • 涉密或内部信息
    • 个人隐私数据
    • 商业机密内容
  `,
  confirmText: '我已了解，继续切换',
  cancelText: '取消',
  type: 'warning'
};

/**
 * 环境切换处理器
 */
class EnvironmentSwitchHandler {
  async handleSwitch(
    from: 'public' | 'private',
    to: 'public' | 'private'
  ): Promise<boolean> {
    // 私域到公网需要确认
    if (from === 'private' && to === 'public') {
      const confirmed = await this.showConfirmDialog(PRIVATE_TO_PUBLIC_CONFIRM);
      
      if (confirmed) {
        // 记录切换日志
        this.logEnvironmentSwitch(from, to);
      }
      
      return confirmed;
    }
    
    // 公网到私域直接切换
    this.logEnvironmentSwitch(from, to);
    return true;
  }
  
  private async showConfirmDialog(config: SwitchConfirmConfig): Promise<boolean> {
    // 由UI层实现
    return new Promise((resolve) => {
      window.dispatchEvent(new CustomEvent('show-confirm-dialog', {
        detail: { config, resolve }
      }));
    });
  }
  
  private logEnvironmentSwitch(from: string, to: string): void {
    AuditLogger.log({
      action: 'ENVIRONMENT_SWITCH',
      from,
      to,
      timestamp: new Date().toISOString()
    });
  }
}
```

---

## 3. 敏感信息检测机制

### 3.1 检测规则

```typescript
/**
 * 敏感信息类型
 */
enum SensitiveType {
  ID_CARD = 'ID_CARD',           // 身份证号
  PHONE = 'PHONE',               // 手机号
  BANK_CARD = 'BANK_CARD',       // 银行卡号
  EMAIL = 'EMAIL',               // 电子邮箱
  CLASSIFIED = 'CLASSIFIED',     // 涉密关键词
  INTERNAL = 'INTERNAL',         // 内部文号
  PASSWORD = 'PASSWORD',         // 密码相关
}

/**
 * 敏感信息检测规则
 */
interface SensitiveRule {
  type: SensitiveType;
  pattern: RegExp;
  description: string;
  severity: 'high' | 'medium' | 'low';
  action: 'block' | 'warn';
}

/**
 * 默认检测规则集
 */
const DEFAULT_SENSITIVE_RULES: SensitiveRule[] = [
  {
    type: SensitiveType.ID_CARD,
    pattern: /(?:^|[^\d])(\d{15}|\d{17}[\dXx])(?:[^\d]|$)/g,
    description: '身份证号码',
    severity: 'high',
    action: 'warn'
  },
  {
    type: SensitiveType.PHONE,
    pattern: /(?:^|[^\d])(1[3-9]\d{9})(?:[^\d]|$)/g,
    description: '手机号码',
    severity: 'medium',
    action: 'warn'
  },
  {
    type: SensitiveType.BANK_CARD,
    pattern: /(?:^|[^\d])(\d{16,19})(?:[^\d]|$)/g,
    description: '银行卡号',
    severity: 'high',
    action: 'warn'
  },
  {
    type: SensitiveType.CLASSIFIED,
    pattern: /(?:绝密|机密|秘密|内部|限制)/g,
    description: '涉密关键词',
    severity: 'high',
    action: 'block'
  },
  {
    type: SensitiveType.INTERNAL,
    pattern: /(?:〔\d{4}〕\d+号|[\u4e00-\u9fa5]+发〔\d{4}〕\d+号)/g,
    description: '内部文号',
    severity: 'medium',
    action: 'warn'
  },
  {
    type: SensitiveType.PASSWORD,
    pattern: /(?:密码|password|pwd|secret)[:：\s]*\S+/gi,
    description: '密码信息',
    severity: 'high',
    action: 'warn'
  }
];
```

### 3.2 检测引擎

```typescript
/**
 * 检测结果
 */
interface SensitiveDetectionResult {
  hasSensitive: boolean;
  findings: SensitiveFinding[];
  summary: {
    high: number;
    medium: number;
    low: number;
  };
  blockedTypes: SensitiveType[];
}

/**
 * 单个发现
 */
interface SensitiveFinding {
  type: SensitiveType;
  content: string;
  maskedContent: string;  // 脱敏后的内容
  position: { start: number; end: number };
  severity: 'high' | 'medium' | 'low';
  action: 'block' | 'warn';
}

/**
 * 敏感信息检测引擎
 */
class SensitiveDetector {
  private rules: SensitiveRule[];
  private enabled: boolean = true;
  
  constructor(customRules?: SensitiveRule[]) {
    this.rules = customRules || DEFAULT_SENSITIVE_RULES;
  }
  
  /**
   * 检测内容中的敏感信息
   */
  detect(content: string): SensitiveDetectionResult {
    if (!this.enabled) {
      return {
        hasSensitive: false,
        findings: [],
        summary: { high: 0, medium: 0, low: 0 },
        blockedTypes: []
      };
    }
    
    const findings: SensitiveFinding[] = [];
    
    for (const rule of this.rules) {
      const matches = content.matchAll(rule.pattern);
      
      for (const match of matches) {
        const matchedContent = match[1] || match[0];
        const startIndex = match.index || 0;
        
        findings.push({
          type: rule.type,
          content: matchedContent,
          maskedContent: this.maskContent(matchedContent, rule.type),
          position: {
            start: startIndex,
            end: startIndex + matchedContent.length
          },
          severity: rule.severity,
          action: rule.action
        });
      }
    }
    
    // 统计各级别数量
    const summary = {
      high: findings.filter(f => f.severity === 'high').length,
      medium: findings.filter(f => f.severity === 'medium').length,
      low: findings.filter(f => f.severity === 'low').length
    };
    
    // 获取被阻止的类型
    const blockedTypes = [...new Set(
      findings.filter(f => f.action === 'block').map(f => f.type)
    )];
    
    return {
      hasSensitive: findings.length > 0,
      findings,
      summary,
      blockedTypes
    };
  }
  
  /**
   * 内容脱敏
   */
  private maskContent(content: string, type: SensitiveType): string {
    switch (type) {
      case SensitiveType.ID_CARD:
        // 保留前3后4
        return content.slice(0, 3) + '***********' + content.slice(-4);
      case SensitiveType.PHONE:
        // 保留前3后4
        return content.slice(0, 3) + '****' + content.slice(-4);
      case SensitiveType.BANK_CARD:
        // 保留前4后4
        return content.slice(0, 4) + '********' + content.slice(-4);
      default:
        // 默认用*替换中间部分
        const len = content.length;
        const showLen = Math.floor(len / 4);
        return content.slice(0, showLen) + '*'.repeat(len - showLen * 2) + content.slice(-showLen);
    }
  }
  
  /**
   * 启用/禁用检测
   */
  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
  }
  
  /**
   * 添加自定义规则
   */
  addRule(rule: SensitiveRule): void {
    this.rules.push(rule);
  }
}
```

### 3.3 检测结果UI展示

```typescript
/**
 * 敏感信息警告组件配置
 */
interface SensitiveWarningConfig {
  result: SensitiveDetectionResult;
  onProceed: () => void;
  onCancel: () => void;
  onMask: () => void;  // 脱敏后继续
}

/**
 * 警告内容模板
 */
const buildWarningContent = (result: SensitiveDetectionResult): string => {
  let content = '检测到以下敏感信息：\n\n';
  
  const grouped = groupBy(result.findings, 'type');
  
  for (const [type, findings] of Object.entries(grouped)) {
    const typeName = getSensitiveTypeName(type as SensitiveType);
    content += `【${typeName}】\n`;
    
    for (const finding of findings as SensitiveFinding[]) {
      content += `  • ${finding.maskedContent}\n`;
    }
    content += '\n';
  }
  
  if (result.blockedTypes.length > 0) {
    content += '\n⚠️ 以下类型的敏感信息将阻止发送：\n';
    for (const type of result.blockedTypes) {
      content += `  • ${getSensitiveTypeName(type)}\n`;
    }
  }
  
  return content;
};
```

---

## 4. 数据加密方案

### 4.1 加密架构

```
┌─────────────────────────────────────────────────────────────────────┐
│                         数据加密架构                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      传输层加密                              │   │
│  │                                                             │   │
│  │  公网请求 ─────────────────────────────> AI云服务            │   │
│  │            TLS 1.2+                                        │   │
│  │            证书验证                                         │   │
│  │            完整性校验                                       │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      存储层加密                              │   │
│  │                                                             │   │
│  │  ┌───────────────┐    ┌───────────────┐    ┌────────────┐ │   │
│  │  │  API密钥      │    │  用户文档      │    │  配置数据  │ │   │
│  │  │  AES-256-GCM │    │  可选加密      │    │  明文存储  │ │   │
│  │  └───────────────┘    └───────────────┘    └────────────┘ │   │
│  │                                                             │   │
│  │  加密密钥来源: 用户密码派生 (PBKDF2) 或 系统密钥链           │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 API密钥加密存储

```typescript
/**
 * 加密服务
 */
class CryptoService {
  private static readonly ALGORITHM = 'AES-GCM';
  private static readonly KEY_LENGTH = 256;
  private static readonly SALT_LENGTH = 16;
  private static readonly IV_LENGTH = 12;
  private static readonly TAG_LENGTH = 16;
  private static readonly ITERATIONS = 100000;
  
  /**
   * 从密码派生加密密钥
   */
  private async deriveKey(password: string, salt: Uint8Array): Promise<CryptoKey> {
    const encoder = new TextEncoder();
    const passwordKey = await crypto.subtle.importKey(
      'raw',
      encoder.encode(password),
      'PBKDF2',
      false,
      ['deriveKey']
    );
    
    return crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt,
        iterations: CryptoService.ITERATIONS,
        hash: 'SHA-256'
      },
      passwordKey,
      {
        name: CryptoService.ALGORITHM,
        length: CryptoService.KEY_LENGTH
      },
      false,
      ['encrypt', 'decrypt']
    );
  }
  
  /**
   * 加密数据
   */
  async encrypt(plaintext: string, password: string): Promise<string> {
    const encoder = new TextEncoder();
    const data = encoder.encode(plaintext);
    
    // 生成随机盐和IV
    const salt = crypto.getRandomValues(new Uint8Array(CryptoService.SALT_LENGTH));
    const iv = crypto.getRandomValues(new Uint8Array(CryptoService.IV_LENGTH));
    
    // 派生密钥
    const key = await this.deriveKey(password, salt);
    
    // 加密
    const ciphertext = await crypto.subtle.encrypt(
      {
        name: CryptoService.ALGORITHM,
        iv,
        tagLength: CryptoService.TAG_LENGTH * 8
      },
      key,
      data
    );
    
    // 组合: salt + iv + ciphertext
    const result = new Uint8Array(salt.length + iv.length + ciphertext.byteLength);
    result.set(salt, 0);
    result.set(iv, salt.length);
    result.set(new Uint8Array(ciphertext), salt.length + iv.length);
    
    // 返回Base64编码
    return btoa(String.fromCharCode(...result));
  }
  
  /**
   * 解密数据
   */
  async decrypt(encrypted: string, password: string): Promise<string> {
    // Base64解码
    const data = Uint8Array.from(atob(encrypted), c => c.charCodeAt(0));
    
    // 提取salt, iv, ciphertext
    const salt = data.slice(0, CryptoService.SALT_LENGTH);
    const iv = data.slice(
      CryptoService.SALT_LENGTH,
      CryptoService.SALT_LENGTH + CryptoService.IV_LENGTH
    );
    const ciphertext = data.slice(CryptoService.SALT_LENGTH + CryptoService.IV_LENGTH);
    
    // 派生密钥
    const key = await this.deriveKey(password, salt);
    
    // 解密
    const plaintext = await crypto.subtle.decrypt(
      {
        name: CryptoService.ALGORITHM,
        iv,
        tagLength: CryptoService.TAG_LENGTH * 8
      },
      key,
      ciphertext
    );
    
    const decoder = new TextDecoder();
    return decoder.decode(plaintext);
  }
}

/**
 * API密钥安全存储
 */
class SecureKeyStore {
  private crypto: CryptoService;
  private masterPassword: string | null = null;
  
  constructor() {
    this.crypto = new CryptoService();
  }
  
  /**
   * 设置主密码（应用启动时）
   */
  setMasterPassword(password: string): void {
    this.masterPassword = password;
  }
  
  /**
   * 存储API密钥
   */
  async storeApiKey(provider: string, apiKey: string): Promise<void> {
    if (!this.masterPassword) {
      throw new Error('主密码未设置');
    }
    
    const encrypted = await this.crypto.encrypt(apiKey, this.masterPassword);
    localStorage.setItem(`encrypted_api_key_${provider}`, encrypted);
  }
  
  /**
   * 获取API密钥
   */
  async getApiKey(provider: string): Promise<string | null> {
    if (!this.masterPassword) {
      throw new Error('主密码未设置');
    }
    
    const encrypted = localStorage.getItem(`encrypted_api_key_${provider}`);
    if (!encrypted) return null;
    
    try {
      return await this.crypto.decrypt(encrypted, this.masterPassword);
    } catch {
      throw new Error('解密失败，密码可能不正确');
    }
  }
  
  /**
   * 删除API密钥
   */
  removeApiKey(provider: string): void {
    localStorage.removeItem(`encrypted_api_key_${provider}`);
  }
}
```

### 4.3 HTTPS传输安全

```typescript
/**
 * 安全HTTP客户端配置
 */
interface SecureHttpConfig {
  /** 是否验证证书 */
  validateCert: boolean;
  /** 最低TLS版本 */
  minTLSVersion: 'TLSv1.2' | 'TLSv1.3';
  /** 请求超时(ms) */
  timeout: number;
  /** 是否允许重定向 */
  allowRedirects: boolean;
}

/**
 * 创建安全HTTP客户端
 */
function createSecureHttpClient(config: SecureHttpConfig): AxiosInstance {
  const client = axios.create({
    timeout: config.timeout,
    maxRedirects: config.allowRedirects ? 5 : 0,
    httpsAgent: new https.Agent({
      rejectUnauthorized: config.validateCert,
      minVersion: config.minTLSVersion
    })
  });
  
  // 请求拦截器 - 添加安全头
  client.interceptors.request.use((config) => {
    config.headers['X-Request-ID'] = generateRequestId();
    return config;
  });
  
  // 响应拦截器 - 验证响应
  client.interceptors.response.use(
    (response) => response,
    (error) => {
      if (error.code === 'CERT_HAS_EXPIRED') {
        throw new SecurityError('服务器证书已过期', 'CERT_EXPIRED');
      }
      if (error.code === 'UNABLE_TO_VERIFY_LEAF_SIGNATURE') {
        throw new SecurityError('无法验证服务器证书', 'CERT_INVALID');
      }
      throw error;
    }
  );
  
  return client;
}
```

---

## 5. 访问控制设计

### 5.1 功能权限控制

```typescript
/**
 * 权限类型
 */
enum Permission {
  // 文档权限
  DOC_CREATE = 'doc:create',
  DOC_READ = 'doc:read',
  DOC_EDIT = 'doc:edit',
  DOC_DELETE = 'doc:delete',
  DOC_EXPORT = 'doc:export',
  
  // AI权限
  AI_GENERATE = 'ai:generate',
  AI_REVIEW = 'ai:review',
  AI_CONFIG = 'ai:config',
  
  // 环境权限
  ENV_SWITCH_PUBLIC = 'env:switch_public',
  ENV_SWITCH_PRIVATE = 'env:switch_private',
  
  // 系统权限
  SYS_CONFIG = 'sys:config',
  SYS_AUDIT_VIEW = 'sys:audit_view',
}

/**
 * 角色定义
 */
interface Role {
  id: string;
  name: string;
  permissions: Permission[];
}

/**
 * 预定义角色
 */
const PREDEFINED_ROLES: Record<string, Role> = {
  // 普通用户 - 仅私域环境
  USER_PRIVATE: {
    id: 'user_private',
    name: '普通用户(私域)',
    permissions: [
      Permission.DOC_CREATE,
      Permission.DOC_READ,
      Permission.DOC_EDIT,
      Permission.DOC_DELETE,
      Permission.DOC_EXPORT,
      Permission.AI_GENERATE,
      Permission.AI_REVIEW,
      Permission.ENV_SWITCH_PRIVATE,
    ]
  },
  
  // 高级用户 - 可使用公网
  USER_FULL: {
    id: 'user_full',
    name: '高级用户',
    permissions: [
      Permission.DOC_CREATE,
      Permission.DOC_READ,
      Permission.DOC_EDIT,
      Permission.DOC_DELETE,
      Permission.DOC_EXPORT,
      Permission.AI_GENERATE,
      Permission.AI_REVIEW,
      Permission.AI_CONFIG,
      Permission.ENV_SWITCH_PUBLIC,
      Permission.ENV_SWITCH_PRIVATE,
    ]
  },
  
  // 管理员
  ADMIN: {
    id: 'admin',
    name: '管理员',
    permissions: Object.values(Permission)
  }
};
```

### 5.2 管理员强制私域模式

```typescript
/**
 * 系统安全策略
 */
interface SecurityPolicy {
  /** 是否强制私域模式 */
  forcePrivateMode: boolean;
  /** 是否启用敏感检测 */
  sensitiveDetectionEnabled: boolean;
  /** 是否允许导出到外部 */
  allowExternalExport: boolean;
  /** 会话超时时间(分钟) */
  sessionTimeout: number;
}

/**
 * 安全策略管理器
 */
class SecurityPolicyManager {
  private policy: SecurityPolicy;
  
  constructor() {
    this.policy = this.loadPolicy();
  }
  
  /**
   * 检查是否强制私域模式
   */
  isForcePrivateMode(): boolean {
    return this.policy.forcePrivateMode;
  }
  
  /**
   * 设置强制私域模式（管理员）
   */
  setForcePrivateMode(enabled: boolean): void {
    this.policy.forcePrivateMode = enabled;
    this.savePolicy();
    
    // 如果启用，立即切换到私域环境
    if (enabled) {
      envManager.forcePrivate();
    }
    
    AuditLogger.log({
      action: 'POLICY_CHANGE',
      detail: { forcePrivateMode: enabled },
      operator: 'admin'
    });
  }
  
  /**
   * 获取当前策略
   */
  getPolicy(): SecurityPolicy {
    return { ...this.policy };
  }
  
  private loadPolicy(): SecurityPolicy {
    const stored = localStorage.getItem('security_policy');
    return stored ? JSON.parse(stored) : {
      forcePrivateMode: false,
      sensitiveDetectionEnabled: true,
      allowExternalExport: true,
      sessionTimeout: 30
    };
  }
  
  private savePolicy(): void {
    localStorage.setItem('security_policy', JSON.stringify(this.policy));
  }
}
```

---

## 6. 审计日志设计

### 6.1 审计事件类型

```typescript
/**
 * 审计事件类型
 */
enum AuditEventType {
  // 环境相关
  ENV_SWITCH = 'ENV_SWITCH',
  
  // AI相关
  AI_REQUEST = 'AI_REQUEST',
  AI_CONFIG_CHANGE = 'AI_CONFIG_CHANGE',
  
  // 文档相关
  DOC_CREATE = 'DOC_CREATE',
  DOC_OPEN = 'DOC_OPEN',
  DOC_SAVE = 'DOC_SAVE',
  DOC_EXPORT = 'DOC_EXPORT',
  DOC_DELETE = 'DOC_DELETE',
  
  // 安全相关
  SENSITIVE_DETECTED = 'SENSITIVE_DETECTED',
  SENSITIVE_BLOCKED = 'SENSITIVE_BLOCKED',
  NETWORK_BLOCKED = 'NETWORK_BLOCKED',
  
  // 系统相关
  APP_START = 'APP_START',
  APP_EXIT = 'APP_EXIT',
  POLICY_CHANGE = 'POLICY_CHANGE',
  ERROR = 'ERROR',
}

/**
 * 审计事件
 */
interface AuditEvent {
  id: string;
  type: AuditEventType;
  timestamp: string;
  environment: 'public' | 'private';
  details: Record<string, any>;
  userId?: string;
}
```

### 6.2 审计日志记录器

```typescript
/**
 * 审计日志记录器
 */
class AuditLogger {
  private static instance: AuditLogger;
  private logFile: string;
  private buffer: AuditEvent[] = [];
  private flushInterval: number = 5000; // 5秒刷新一次
  
  private constructor() {
    this.logFile = this.getLogFilePath();
    this.startFlushTimer();
  }
  
  static getInstance(): AuditLogger {
    if (!AuditLogger.instance) {
      AuditLogger.instance = new AuditLogger();
    }
    return AuditLogger.instance;
  }
  
  /**
   * 记录审计事件
   */
  static log(event: Omit<AuditEvent, 'id' | 'timestamp' | 'environment'>): void {
    const instance = AuditLogger.getInstance();
    
    const fullEvent: AuditEvent = {
      id: generateUUID(),
      timestamp: new Date().toISOString(),
      environment: envManager.getCurrentEnvironment().type,
      ...event
    };
    
    instance.buffer.push(fullEvent);
    
    // 如果是高优先级事件，立即刷新
    if (instance.isHighPriorityEvent(fullEvent.type)) {
      instance.flush();
    }
  }
  
  /**
   * 查询审计日志
   */
  async query(options: {
    startDate?: Date;
    endDate?: Date;
    types?: AuditEventType[];
    limit?: number;
  }): Promise<AuditEvent[]> {
    // 从日志文件查询...
    return [];
  }
  
  /**
   * 导出审计日志
   */
  async export(options: {
    startDate: Date;
    endDate: Date;
    format: 'json' | 'csv';
  }): Promise<string> {
    const events = await this.query({
      startDate: options.startDate,
      endDate: options.endDate
    });
    
    if (options.format === 'csv') {
      return this.toCSV(events);
    }
    return JSON.stringify(events, null, 2);
  }
  
  private isHighPriorityEvent(type: AuditEventType): boolean {
    return [
      AuditEventType.SENSITIVE_BLOCKED,
      AuditEventType.NETWORK_BLOCKED,
      AuditEventType.ERROR
    ].includes(type);
  }
  
  private async flush(): Promise<void> {
    if (this.buffer.length === 0) return;
    
    const events = [...this.buffer];
    this.buffer = [];
    
    // 写入日志文件
    await this.writeToFile(events);
  }
  
  private startFlushTimer(): void {
    setInterval(() => this.flush(), this.flushInterval);
  }
  
  private getLogFilePath(): string {
    const date = new Date().toISOString().split('T')[0];
    return `logs/audit_${date}.log`;
  }
  
  private async writeToFile(events: AuditEvent[]): Promise<void> {
    // 通过IPC写入文件...
  }
  
  private toCSV(events: AuditEvent[]): string {
    const headers = ['ID', 'Timestamp', 'Type', 'Environment', 'Details'];
    const rows = events.map(e => [
      e.id,
      e.timestamp,
      e.type,
      e.environment,
      JSON.stringify(e.details)
    ]);
    
    return [headers, ...rows].map(row => row.join(',')).join('\n');
  }
}
```

---

## 7. 安全最佳实践

### 7.1 开发安全规范

| 规范 | 说明 |
|------|------|
| 输入验证 | 所有用户输入必须验证和转义 |
| 输出编码 | 输出到页面的内容必须HTML编码 |
| 密钥管理 | API密钥必须加密存储，不得硬编码 |
| 错误处理 | 错误信息不得暴露敏感细节 |
| 依赖安全 | 定期更新依赖，检查安全漏洞 |
| 代码审查 | 安全相关代码必须经过审查 |

### 7.2 安全检查清单

```
□ 公私隔离机制正常工作
□ 私域环境无法访问公网
□ 环境切换有正确的确认提示
□ 敏感信息检测功能正常
□ API密钥加密存储
□ HTTPS证书验证启用
□ 审计日志正常记录
□ 错误信息不暴露敏感信息
□ 无硬编码的密钥或凭证
```

---

## 8. 附录

### 8.1 安全相关配置项

| 配置项 | 默认值 | 说明 |
|--------|--------|------|
| `security.forcePrivateMode` | false | 强制私域模式 |
| `security.sensitiveDetection` | true | 敏感信息检测 |
| `security.auditLogEnabled` | true | 审计日志开关 |
| `security.auditLogRetention` | 90 | 日志保留天数 |
| `security.sessionTimeout` | 30 | 会话超时(分钟) |
| `network.tlsMinVersion` | TLSv1.2 | 最低TLS版本 |
| `network.certValidation` | true | 证书验证 |

### 8.2 安全事件响应流程

```
1. 发现安全事件
       ↓
2. 记录到审计日志
       ↓
3. 根据严重程度采取行动
   - 高: 阻止操作 + 弹窗警告
   - 中: 弹窗警告 + 用户确认
   - 低: 仅记录日志
       ↓
4. 用户决策
   - 继续: 记录用户确认
   - 取消: 记录用户取消
       ↓
5. 后续分析（可选）
```

---

*文档结束*
