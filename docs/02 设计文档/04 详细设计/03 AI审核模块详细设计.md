# AI审核模块详细设计

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档版本 | V1.0 |
| 文档状态 | 已完成 |
| 创建日期 | 2026-03-01 |
| 最后更新 | 2026-03-01 |

---

## 1. 模块概述

### 1.1 模块职责

AI审核模块负责对公文内容进行智能审核和格式检查，核心职责包括：

- 利用AI对公文内容进行逻辑检查、事实核查、政策合规检查
- 基于规则引擎对公文格式进行规范性检查（字体、字号、行距、页边距等）
- 本地执行敏感词和语病检测
- 生成包含问题列表、修改建议和评分的审核报告
- 提供可自动修复的格式问题的一键修复功能

### 1.2 模块边界

```
┌─────────────────────────────────────────────────────────────────────┐
│                       AI审核模块边界                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  输入                                                                │
│  ├─ 待审核的文档内容（纯文本 + 格式信息）                           │
│  ├─ 文档类型（通知/报告/请示等）                                    │
│  ├─ 审核类型选择（内容/格式/全部）                                  │
│  └─ 自定义审核规则（可选）                                          │
│                                                                     │
│  输出                                                                │
│  ├─ 审核报告（通过/不通过、评分、问题列表）                         │
│  ├─ 问题定位信息（精确到文档中的位置）                              │
│  ├─ 修改建议列表                                                    │
│  └─ 自动修复操作（针对可修复的格式问题）                            │
│                                                                     │
│  依赖                                                                │
│  ├─ AI集成模块 (AIServiceManager) — 内容审核的AI调用                │
│  ├─ 数据层 (AuditRecordRepository) — 审核记录持久化                 │
│  └─ 环境管理器 (EnvironmentManager) — 环境感知                      │
│                                                                     │
│  被依赖                                                              │
│  ├─ 公文编写模块（调用审核功能，展示审核结果）                      │
│  └─ 文档管理模块（文档状态变更：draft → reviewing → final）         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. 审核引擎设计

### 2.1 类图

```
┌─────────────────────────────────────────────────────────────────────┐
│                          审核引擎类图                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────┐                                           │
│  │   ReviewEngine      │                                           │
│  │   (审核引擎-入口)    │                                           │
│  ├─────────────────────┤                                           │
│  │ - contentReviewer   │                                           │
│  │ - formatChecker     │                                           │
│  │ - ruleEngine        │                                           │
│  │ - reportGenerator   │                                           │
│  ├─────────────────────┤                                           │
│  │ + review()          │                                           │
│  │ + reviewContent()   │                                           │
│  │ + reviewFormat()    │                                           │
│  │ + getLastReport()   │                                           │
│  └─────────┬───────────┘                                           │
│            │                                                        │
│            │ 编排                                                    │
│  ┌─────────┼───────────────────────────────┐                       │
│  │         │                               │                       │
│  ▼         ▼                               ▼                       │
│ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐       │
│ │ ContentReviewer │ │  FormatChecker  │ │  LocalChecker   │       │
│ │ (内容审核器)     │ │  (格式检查器)   │ │  (本地检查器)    │       │
│ ├─────────────────┤ ├─────────────────┤ ├─────────────────┤       │
│ │ - aiService     │ │ - formatRules   │ │ - sensitiveRules│       │
│ │ - promptMgr     │ │ - formatConfig  │ │ - languageRules │       │
│ ├─────────────────┤ ├─────────────────┤ ├─────────────────┤       │
│ │ + reviewLogic() │ │ + checkFont()   │ │ + checkSensitive│       │
│ │ + reviewFacts() │ │ + checkSpacing()│ │ + checkLanguage │       │
│ │ + reviewPolicy()│ │ + checkMargins()│ │ + checkDuplicate│       │
│ └─────────────────┘ │ + checkNumbering│ └─────────────────┘       │
│                     └─────────────────┘                            │
│                                                                     │
│  ┌─────────────────────┐       ┌─────────────────────┐             │
│  │  RuleEngine         │       │  ReportGenerator    │             │
│  │  (规则引擎)          │       │  (报告生成器)        │             │
│  ├─────────────────────┤       ├─────────────────────┤             │
│  │ - rules             │       │ + generate()        │             │
│  │ - customRules       │       │ + formatAsHTML()    │             │
│  ├─────────────────────┤       │ + exportReport()    │             │
│  │ + addRule()         │       └─────────────────────┘             │
│  │ + removeRule()      │                                           │
│  │ + evaluate()        │       ┌─────────────────────┐             │
│  └─────────────────────┘       │  AutoFixer          │             │
│                                │  (自动修复器)        │             │
│                                ├─────────────────────┤             │
│                                │ + getFixableIssues()│             │
│                                │ + fixIssue()        │             │
│                                │ + fixAll()          │             │
│                                └─────────────────────┘             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 ReviewEngine（审核引擎入口）

```typescript
/**
 * 审核引擎
 * 编排各子审核器，汇总审核结果
 */
class ReviewEngine {
  private contentReviewer: ContentReviewer;
  private formatChecker: FormatChecker;
  private localChecker: LocalChecker;
  private reportGenerator: ReportGenerator;
  private autoFixer: AutoFixer;

  constructor() {
    this.contentReviewer = new ContentReviewer();
    this.formatChecker = new FormatChecker();
    this.localChecker = new LocalChecker();
    this.reportGenerator = new ReportGenerator();
    this.autoFixer = new AutoFixer();
  }

  /**
   * 执行完整审核（内容+格式+本地检查）
   */
  async review(request: ReviewRequest): Promise<ReviewReport> {
    const issues: ReviewIssue[] = [];
    const scores: Record<string, number> = {};

    // 1. 本地检查（不依赖AI，始终执行）
    const localResult = this.localChecker.check(request.content, request.docType);
    issues.push(...localResult.issues);
    scores.language = localResult.scores.language;

    // 2. 格式检查（不依赖AI，本地规则引擎执行）
    if (request.reviewTypes.includes('format') || request.reviewTypes.includes('all')) {
      const formatResult = this.formatChecker.check(
        request.formatInfo,
        request.docType
      );
      issues.push(...formatResult.issues);
      scores.format = formatResult.score;
    }

    // 3. AI内容审核
    if (request.reviewTypes.includes('content') || request.reviewTypes.includes('all')) {
      const contentResult = await this.contentReviewer.review(
        request.content,
        request.docType,
        request.customRules
      );
      issues.push(...contentResult.issues);
      scores.content = contentResult.scores.content;
      scores.logic = contentResult.scores.logic;
      scores.policy = contentResult.scores.policy;
    }

    // 4. 生成审核报告
    const report = this.reportGenerator.generate(issues, scores, request);

    // 5. 保存审核记录
    await this.saveAuditRecord(request, report);

    return report;
  }

  /**
   * 仅执行内容审核
   */
  async reviewContent(content: string, docType: DocType): Promise<ReviewReport> {
    return this.review({
      content,
      docType,
      reviewTypes: ['content'],
    });
  }

  /**
   * 仅执行格式审核
   */
  async reviewFormat(formatInfo: DocumentFormatInfo, docType: DocType): Promise<ReviewReport> {
    return this.review({
      content: '',
      formatInfo,
      docType,
      reviewTypes: ['format'],
    });
  }

  /**
   * 获取可自动修复的问题列表
   */
  getFixableIssues(report: ReviewReport): ReviewIssue[] {
    return this.autoFixer.getFixableIssues(report.issues);
  }

  /**
   * 自动修复单个问题
   */
  async fixIssue(issue: ReviewIssue, editor: Editor): Promise<boolean> {
    return this.autoFixer.fixIssue(issue, editor);
  }

  /**
   * 自动修复所有可修复的问题
   */
  async fixAll(report: ReviewReport, editor: Editor): Promise<FixResult> {
    return this.autoFixer.fixAll(report.issues, editor);
  }

  private async saveAuditRecord(request: ReviewRequest, report: ReviewReport): Promise<void> {
    await window.electronAPI.audit.create({
      document_id: request.documentId || '',
      audit_type: request.reviewTypes.includes('all') ? 'all'
        : request.reviewTypes[0],
      passed: report.passed ? 1 : 0,
      score: report.score,
      issues: JSON.stringify(report.issues),
      suggestions: JSON.stringify(report.suggestions),
    });
  }
}
```

---

## 3. 规则引擎设计

### 3.1 规则结构

```typescript
/**
 * 审核规则
 */
interface ReviewRule {
  id: string;
  name: string;
  description: string;
  category: 'format' | 'content' | 'language' | 'sensitive' | 'custom';
  severity: 'high' | 'medium' | 'low';
  enabled: boolean;
  autoFixable: boolean;

  /**
   * 规则检查函数
   * 返回发现的问题列表
   */
  check: (context: RuleContext) => ReviewIssue[];
}

/**
 * 规则检查上下文
 */
interface RuleContext {
  content: string;                       // 文档纯文本
  formatInfo?: DocumentFormatInfo;       // 文档格式信息
  docType: DocType;                      // 文档类型
  formatConfig: OfficialFormatConfig;    // 目标格式配置
}

/**
 * 文档格式信息（从编辑器提取）
 */
interface DocumentFormatInfo {
  title?: {
    font?: string;
    size?: number;
    align?: string;
    bold?: boolean;
  };
  body?: {
    font?: string;
    size?: number;
    lineHeight?: number;
    firstIndent?: string;
  };
  page?: {
    margins?: { top: number; bottom: number; left: number; right: number };
    size?: string;
  };
  paragraphs: ParagraphFormatInfo[];
  headings: HeadingFormatInfo[];
}

interface ParagraphFormatInfo {
  index: number;
  position: { start: number; end: number };
  font?: string;
  size?: number;
  lineHeight?: number;
  indent?: string;
}

interface HeadingFormatInfo {
  level: number;
  position: { start: number; end: number };
  font?: string;
  size?: number;
  align?: string;
  text: string;
}
```

### 3.2 规则引擎

```typescript
/**
 * 规则引擎
 * 管理和执行所有审核规则
 */
class RuleEngine {
  private rules: Map<string, ReviewRule> = new Map();

  constructor() {
    this.loadBuiltinRules();
  }

  /**
   * 加载内置规则集
   */
  private loadBuiltinRules(): void {
    // 格式规则
    FORMAT_RULES.forEach(rule => this.rules.set(rule.id, rule));
    // 语言规则
    LANGUAGE_RULES.forEach(rule => this.rules.set(rule.id, rule));
    // 敏感词规则
    SENSITIVE_RULES.forEach(rule => this.rules.set(rule.id, rule));
  }

  /**
   * 添加自定义规则
   */
  addRule(rule: ReviewRule): void {
    this.rules.set(rule.id, rule);
  }

  /**
   * 移除规则
   */
  removeRule(ruleId: string): void {
    this.rules.delete(ruleId);
  }

  /**
   * 启用/禁用规则
   */
  setRuleEnabled(ruleId: string, enabled: boolean): void {
    const rule = this.rules.get(ruleId);
    if (rule) rule.enabled = enabled;
  }

  /**
   * 执行指定分类的规则
   */
  evaluate(context: RuleContext, categories?: string[]): ReviewIssue[] {
    const issues: ReviewIssue[] = [];

    for (const rule of this.rules.values()) {
      if (!rule.enabled) continue;
      if (categories && !categories.includes(rule.category)) continue;

      try {
        const ruleIssues = rule.check(context);
        issues.push(...ruleIssues);
      } catch (error) {
        console.error(`规则 ${rule.id} 执行失败:`, error);
      }
    }

    return issues;
  }

  /**
   * 获取所有规则列表
   */
  getRules(category?: string): ReviewRule[] {
    const rules = Array.from(this.rules.values());
    return category ? rules.filter(r => r.category === category) : rules;
  }
}
```

### 3.3 内置格式规则集

```typescript
/**
 * 内置格式检查规则
 */
const FORMAT_RULES: ReviewRule[] = [
  {
    id: 'FMT-001',
    name: '标题字号检查',
    description: '检查公文标题是否使用二号字（22pt）',
    category: 'format',
    severity: 'high',
    enabled: true,
    autoFixable: true,
    check: (ctx) => {
      const issues: ReviewIssue[] = [];
      if (!ctx.formatInfo) return issues;

      for (const heading of ctx.formatInfo.headings) {
        if (heading.level === 1 && heading.size !== ctx.formatConfig.title.size) {
          issues.push({
            id: generateUUID(),
            ruleId: 'FMT-001',
            type: 'format',
            severity: 'high',
            description: `标题字号应为${ctx.formatConfig.title.size}pt（二号），当前为${heading.size || '未设置'}`,
            position: heading.position,
            originalText: heading.text,
            suggestion: `将标题字号修改为${ctx.formatConfig.title.size}pt`,
            autoFixable: true,
            fixAction: {
              type: 'change_font_size',
              target: 'heading',
              value: ctx.formatConfig.title.size,
            },
          });
        }
      }
      return issues;
    },
  },

  {
    id: 'FMT-002',
    name: '标题字体检查',
    description: '检查公文标题是否使用方正小标宋或黑体',
    category: 'format',
    severity: 'high',
    enabled: true,
    autoFixable: true,
    check: (ctx) => {
      const issues: ReviewIssue[] = [];
      if (!ctx.formatInfo) return issues;

      const validFonts = ['方正小标宋', '黑体'];
      for (const heading of ctx.formatInfo.headings) {
        if (heading.level === 1 && heading.font && !validFonts.includes(heading.font)) {
          issues.push({
            id: generateUUID(),
            ruleId: 'FMT-002',
            type: 'format',
            severity: 'high',
            description: `标题字体应为方正小标宋或黑体，当前为"${heading.font}"`,
            position: heading.position,
            suggestion: '将标题字体修改为方正小标宋',
            autoFixable: true,
            fixAction: {
              type: 'change_font',
              target: 'heading',
              value: ctx.formatConfig.title.font,
            },
          });
        }
      }
      return issues;
    },
  },

  {
    id: 'FMT-003',
    name: '正文字号检查',
    description: '检查正文是否使用三号字（16pt）',
    category: 'format',
    severity: 'high',
    enabled: true,
    autoFixable: true,
    check: (ctx) => {
      const issues: ReviewIssue[] = [];
      if (!ctx.formatInfo) return issues;

      for (const para of ctx.formatInfo.paragraphs) {
        if (para.size && Math.abs(para.size - ctx.formatConfig.body.size) > 1) {
          issues.push({
            id: generateUUID(),
            ruleId: 'FMT-003',
            type: 'format',
            severity: 'high',
            description: `第${para.index + 1}段正文字号应为${ctx.formatConfig.body.size}pt（三号），当前为${para.size}pt`,
            position: para.position,
            suggestion: `将正文字号修改为${ctx.formatConfig.body.size}pt`,
            autoFixable: true,
            fixAction: {
              type: 'change_font_size',
              target: 'paragraph',
              targetIndex: para.index,
              value: ctx.formatConfig.body.size,
            },
          });
        }
      }
      return issues;
    },
  },

  {
    id: 'FMT-004',
    name: '行距检查',
    description: '检查正文行距是否为固定值28-30磅',
    category: 'format',
    severity: 'medium',
    enabled: true,
    autoFixable: true,
    check: (ctx) => {
      const issues: ReviewIssue[] = [];
      if (!ctx.formatInfo) return issues;

      for (const para of ctx.formatInfo.paragraphs) {
        if (para.lineHeight && (para.lineHeight < 28 || para.lineHeight > 30)) {
          issues.push({
            id: generateUUID(),
            ruleId: 'FMT-004',
            type: 'format',
            severity: 'medium',
            description: `第${para.index + 1}段行距应为28-30磅，当前为${para.lineHeight}磅`,
            position: para.position,
            suggestion: '将行距修改为28磅',
            autoFixable: true,
            fixAction: {
              type: 'change_line_height',
              target: 'paragraph',
              targetIndex: para.index,
              value: 28,
            },
          });
        }
      }
      return issues;
    },
  },

  {
    id: 'FMT-005',
    name: '首行缩进检查',
    description: '检查正文段落首行缩进是否为2字符',
    category: 'format',
    severity: 'medium',
    enabled: true,
    autoFixable: true,
    check: (ctx) => {
      const issues: ReviewIssue[] = [];
      if (!ctx.formatInfo) return issues;

      for (const para of ctx.formatInfo.paragraphs) {
        if (para.indent && para.indent !== '2em') {
          issues.push({
            id: generateUUID(),
            ruleId: 'FMT-005',
            type: 'format',
            severity: 'medium',
            description: `第${para.index + 1}段首行缩进应为2字符，当前为"${para.indent}"`,
            position: para.position,
            suggestion: '将首行缩进修改为2字符',
            autoFixable: true,
            fixAction: {
              type: 'change_indent',
              target: 'paragraph',
              targetIndex: para.index,
              value: '2em',
            },
          });
        }
      }
      return issues;
    },
  },

  {
    id: 'FMT-006',
    name: '页边距检查',
    description: '检查页边距是否符合公文标准（上37mm 下35mm 左28mm 右26mm）',
    category: 'format',
    severity: 'high',
    enabled: true,
    autoFixable: true,
    check: (ctx) => {
      const issues: ReviewIssue[] = [];
      if (!ctx.formatInfo?.page?.margins) return issues;

      const margins = ctx.formatInfo.page.margins;
      const expected = ctx.formatConfig.page.margins;
      const tolerance = 2; // mm

      const checks = [
        { name: '上', actual: margins.top, expected: expected.top },
        { name: '下', actual: margins.bottom, expected: expected.bottom },
        { name: '左', actual: margins.left, expected: expected.left },
        { name: '右', actual: margins.right, expected: expected.right },
      ];

      for (const check of checks) {
        if (Math.abs(check.actual - check.expected) > tolerance) {
          issues.push({
            id: generateUUID(),
            ruleId: 'FMT-006',
            type: 'format',
            severity: 'high',
            description: `${check.name}页边距应为${check.expected}mm（容差±${tolerance}mm），当前为${check.actual}mm`,
            suggestion: `将${check.name}页边距修改为${check.expected}mm`,
            autoFixable: true,
            fixAction: {
              type: 'change_margin',
              target: 'page',
              side: check.name,
              value: check.expected,
            },
          });
        }
      }
      return issues;
    },
  },
];
```

---

## 4. 格式检查逻辑

### 4.1 FormatChecker（格式检查器）

```typescript
/**
 * 格式检查器
 * 检查文档格式是否符合公文标准
 */
class FormatChecker {
  private ruleEngine: RuleEngine;
  private formatConfig: OfficialFormatConfig;

  constructor() {
    this.ruleEngine = new RuleEngine();
    this.formatConfig = DEFAULT_OFFICIAL_FORMAT;
  }

  /**
   * 执行格式检查
   */
  check(formatInfo: DocumentFormatInfo | undefined, docType: DocType): FormatCheckResult {
    if (!formatInfo) {
      return { issues: [], score: 100 };
    }

    const context: RuleContext = {
      content: '',
      formatInfo,
      docType,
      formatConfig: this.formatConfig,
    };

    const issues = this.ruleEngine.evaluate(context, ['format']);

    // 计算格式得分
    const score = this.calculateScore(issues);

    return { issues, score };
  }

  /**
   * 计算格式得分
   */
  private calculateScore(issues: ReviewIssue[]): number {
    let score = 100;
    for (const issue of issues) {
      switch (issue.severity) {
        case 'high': score -= 15; break;
        case 'medium': score -= 8; break;
        case 'low': score -= 3; break;
      }
    }
    return Math.max(0, score);
  }

  /**
   * 更新格式配置
   */
  setFormatConfig(config: OfficialFormatConfig): void {
    this.formatConfig = config;
  }
}
```

---

## 5. 内容检查逻辑

### 5.1 ContentReviewer（AI内容审核器）

```typescript
/**
 * AI内容审核器
 * 利用AI进行内容层面的审核
 */
class ContentReviewer {
  private aiService: AIServiceManager;
  private promptManager: PromptManager;

  constructor() {
    this.aiService = AIServiceManager.getInstance();
    this.promptManager = new PromptManager();
  }

  /**
   * 执行内容审核
   */
  async review(
    content: string,
    docType: DocType,
    customRules?: string[]
  ): Promise<ContentReviewResult> {
    const systemPrompt = this.buildSystemPrompt(docType);
    const userPrompt = this.buildUserPrompt(content, docType, customRules);

    const response = await this.aiService.generate({
      systemPrompt,
      userPrompt,
      options: {
        temperature: 0.3, // 低温度确保审核结果稳定
        maxTokens: 4096,
      }
    });

    // 解析AI返回的审核结果
    return this.parseReviewResponse(response.content);
  }

  /**
   * 构建系统提示词
   */
  private buildSystemPrompt(docType: DocType): string {
    return `你是一位资深的公文审核专家，擅长审核${DOC_TYPE_NAME_MAP[docType]}类公文。
请从以下维度对公文内容进行审核：

1. **逻辑检查**：文章结构是否清晰，论述是否有逻辑性，各部分是否连贯
2. **事实核查**：文中数据、日期、人名是否准确一致
3. **政策合规**：内容是否符合相关政策法规要求
4. **用语规范**：公文用语是否规范，是否存在口语化表述

请以JSON格式返回审核结果，格式如下：
{
  "scores": { "content": 0-100, "logic": 0-100, "policy": 0-100 },
  "issues": [
    {
      "type": "content|logic|policy",
      "severity": "high|medium|low",
      "description": "问题描述",
      "originalText": "原文引用",
      "suggestion": "修改建议"
    }
  ],
  "summary": "总体评价"
}`;
  }

  /**
   * 构建用户提示词
   */
  private buildUserPrompt(content: string, docType: DocType, customRules?: string[]): string {
    let prompt = `请审核以下${DOC_TYPE_NAME_MAP[docType]}：\n\n${content}\n`;

    if (customRules && customRules.length > 0) {
      prompt += `\n额外审核规则：\n`;
      customRules.forEach((rule, i) => {
        prompt += `${i + 1}. ${rule}\n`;
      });
    }

    return prompt;
  }

  /**
   * 解析AI审核响应
   */
  private parseReviewResponse(responseText: string): ContentReviewResult {
    try {
      // 尝试提取JSON
      const jsonMatch = responseText.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('AI响应中未找到有效JSON');
      }

      const parsed = JSON.parse(jsonMatch[0]);

      const issues: ReviewIssue[] = (parsed.issues || []).map((item: any) => ({
        id: generateUUID(),
        ruleId: 'AI-REVIEW',
        type: item.type || 'content',
        severity: item.severity || 'medium',
        description: item.description,
        originalText: item.originalText,
        suggestion: item.suggestion,
        autoFixable: false,
      }));

      return {
        scores: {
          content: parsed.scores?.content ?? 80,
          logic: parsed.scores?.logic ?? 80,
          policy: parsed.scores?.policy ?? 80,
        },
        issues,
        summary: parsed.summary || '',
      };
    } catch (error) {
      // 解析失败时返回默认结果
      return {
        scores: { content: 0, logic: 0, policy: 0 },
        issues: [{
          id: generateUUID(),
          ruleId: 'PARSE-ERROR',
          type: 'content',
          severity: 'low',
          description: 'AI审核结果解析失败，请重新审核',
          suggestion: '请重新发起审核',
          autoFixable: false,
        }],
        summary: '审核结果解析失败',
      };
    }
  }
}
```

### 5.2 LocalChecker（本地检查器）

```typescript
/**
 * 本地检查器
 * 不依赖AI的本地规则检查
 */
class LocalChecker {
  private sensitiveDetector: SensitiveDetector;
  private ruleEngine: RuleEngine;

  constructor() {
    this.sensitiveDetector = new SensitiveDetector();
    this.ruleEngine = new RuleEngine();
  }

  /**
   * 执行本地检查
   */
  check(content: string, docType: DocType): LocalCheckResult {
    const issues: ReviewIssue[] = [];

    // 1. 敏感词检测
    issues.push(...this.checkSensitiveWords(content));

    // 2. 语言检查（错别字、标点符号）
    issues.push(...this.checkLanguage(content));

    // 3. 重复内容检查
    issues.push(...this.checkDuplicate(content));

    // 4. 序号格式检查
    issues.push(...this.checkNumbering(content, docType));

    // 计算语言得分
    const languageScore = Math.max(0, 100 - issues.filter(
      i => i.type === 'language'
    ).length * 5);

    return {
      issues,
      scores: { language: languageScore },
    };
  }

  /**
   * 敏感词检查
   */
  private checkSensitiveWords(content: string): ReviewIssue[] {
    const result = this.sensitiveDetector.detect(content);
    return result.findings.map(finding => ({
      id: generateUUID(),
      ruleId: 'SENSITIVE',
      type: 'language' as const,
      severity: finding.severity,
      description: `检测到${finding.type === 'CLASSIFIED' ? '涉密' : '敏感'}信息: ${finding.maskedContent}`,
      position: finding.position,
      originalText: finding.maskedContent,
      suggestion: '请检查并处理敏感信息',
      autoFixable: false,
    }));
  }

  /**
   * 语言检查（标点符号等）
   */
  private checkLanguage(content: string): ReviewIssue[] {
    const issues: ReviewIssue[] = [];

    // 检查英文标点在中文语境中的误用
    const wrongPunctuations = [
      { pattern: /(?<=[\u4e00-\u9fa5]),(?=[\u4e00-\u9fa5])/g, desc: '中文语境使用了英文逗号', fix: '，' },
      { pattern: /(?<=[\u4e00-\u9fa5])\.(?=[\u4e00-\u9fa5])/g, desc: '中文语境使用了英文句号', fix: '。' },
      { pattern: /(?<=[\u4e00-\u9fa5]);(?=[\u4e00-\u9fa5])/g, desc: '中文语境使用了英文分号', fix: '；' },
      { pattern: /(?<=[\u4e00-\u9fa5]):(?=[\u4e00-\u9fa5])/g, desc: '中文语境使用了英文冒号', fix: '：' },
      { pattern: /(?<=[\u4e00-\u9fa5])\?(?=[\u4e00-\u9fa5])/g, desc: '中文语境使用了英文问号', fix: '？' },
    ];

    for (const rule of wrongPunctuations) {
      let match;
      while ((match = rule.pattern.exec(content)) !== null) {
        issues.push({
          id: generateUUID(),
          ruleId: 'LANG-PUNCTUATION',
          type: 'language',
          severity: 'low',
          description: rule.desc,
          position: { start: match.index, end: match.index + 1 },
          originalText: match[0],
          suggestion: `建议替换为"${rule.fix}"`,
          autoFixable: true,
          fixAction: {
            type: 'replace_text',
            position: { start: match.index, end: match.index + 1 },
            value: rule.fix,
          },
        });
      }
    }

    return issues;
  }

  /**
   * 重复内容检查
   */
  private checkDuplicate(content: string): ReviewIssue[] {
    const issues: ReviewIssue[] = [];
    const sentences = content.split(/[。！？\n]/).filter(s => s.trim().length > 10);

    for (let i = 0; i < sentences.length; i++) {
      for (let j = i + 1; j < sentences.length; j++) {
        const similarity = this.calculateSimilarity(sentences[i].trim(), sentences[j].trim());
        if (similarity > 0.85) {
          issues.push({
            id: generateUUID(),
            ruleId: 'DUPLICATE',
            type: 'content',
            severity: 'low',
            description: `发现高度相似的重复内容（相似度${Math.round(similarity * 100)}%）`,
            originalText: sentences[j].trim().substring(0, 50) + '...',
            suggestion: '建议合并或删除重复表述',
            autoFixable: false,
          });
        }
      }
    }
    return issues;
  }

  /**
   * 序号格式检查
   */
  private checkNumbering(content: string, docType: DocType): ReviewIssue[] {
    const issues: ReviewIssue[] = [];
    const lines = content.split('\n');

    // 检查一级序号是否使用"一、二、三、"格式
    const level1Pattern = /^[一二三四五六七八九十]+、/;
    const wrongLevel1 = /^[1-9]\.|^[（(][1-9][)）]/;

    let expectingLevel1 = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (wrongLevel1.test(line) && !level1Pattern.test(line)) {
        // 判断上下文是否应该是一级标题
        if (line.length < 30 && !line.includes('。')) {
          issues.push({
            id: generateUUID(),
            ruleId: 'NUMBERING-001',
            type: 'format',
            severity: 'medium',
            description: `第${i + 1}行序号格式可能不规范，一级序号应使用"一、二、三、"格式`,
            originalText: line.substring(0, 20),
            suggestion: '建议使用"一、二、三、"格式的一级序号',
            autoFixable: false,
          });
        }
      }
    }

    return issues;
  }

  /**
   * 计算两个字符串的相似度（简化版Jaccard）
   */
  private calculateSimilarity(str1: string, str2: string): number {
    const set1 = new Set(str1.split(''));
    const set2 = new Set(str2.split(''));
    const intersection = new Set([...set1].filter(x => set2.has(x)));
    const union = new Set([...set1, ...set2]);
    return intersection.size / union.size;
  }
}
```

---

## 6. 审核报告生成

### 6.1 ReportGenerator（报告生成器）

```typescript
/**
 * 审核报告生成器
 */
class ReportGenerator {
  /**
   * 生成审核报告
   */
  generate(
    issues: ReviewIssue[],
    scores: Record<string, number>,
    request: ReviewRequest
  ): ReviewReport {
    // 计算总分
    const scoreValues = Object.values(scores).filter(v => v !== undefined);
    const totalScore = scoreValues.length > 0
      ? Math.round(scoreValues.reduce((a, b) => a + b, 0) / scoreValues.length)
      : 0;

    // 判断是否通过
    const hasHighSeverity = issues.some(i => i.severity === 'high');
    const passed = totalScore >= 70 && !hasHighSeverity;

    // 按严重程度分组统计
    const statistics = {
      total: issues.length,
      high: issues.filter(i => i.severity === 'high').length,
      medium: issues.filter(i => i.severity === 'medium').length,
      low: issues.filter(i => i.severity === 'low').length,
      autoFixable: issues.filter(i => i.autoFixable).length,
    };

    // 按类型分组
    const issuesByType = this.groupByType(issues);

    // 生成修改建议摘要
    const suggestions = this.generateSuggestions(issues, scores);

    return {
      id: generateUUID(),
      documentId: request.documentId,
      timestamp: new Date().toISOString(),
      passed,
      score: totalScore,
      scores,
      statistics,
      issues: this.sortIssues(issues),
      issuesByType,
      suggestions,
      summary: this.generateSummary(passed, totalScore, statistics),
    };
  }

  /**
   * 按严重程度排序问题
   */
  private sortIssues(issues: ReviewIssue[]): ReviewIssue[] {
    const severityOrder = { high: 0, medium: 1, low: 2 };
    return [...issues].sort((a, b) =>
      severityOrder[a.severity] - severityOrder[b.severity]
    );
  }

  /**
   * 按类型分组
   */
  private groupByType(issues: ReviewIssue[]): Record<string, ReviewIssue[]> {
    const grouped: Record<string, ReviewIssue[]> = {};
    for (const issue of issues) {
      if (!grouped[issue.type]) grouped[issue.type] = [];
      grouped[issue.type].push(issue);
    }
    return grouped;
  }

  /**
   * 生成修改建议摘要
   */
  private generateSuggestions(issues: ReviewIssue[], scores: Record<string, number>): string[] {
    const suggestions: string[] = [];

    if ((scores.format ?? 100) < 80) {
      suggestions.push('文档格式存在较多不规范之处，建议使用"一键格式化"功能统一修正');
    }
    if ((scores.content ?? 100) < 80) {
      suggestions.push('文档内容表述需要优化，建议重点关注标记为"高"严重程度的问题');
    }
    if ((scores.logic ?? 100) < 80) {
      suggestions.push('文章结构和逻辑性有待提升，建议重新梳理文章脉络');
    }
    if ((scores.language ?? 100) < 90) {
      suggestions.push('存在标点符号或用语不规范问题，建议逐项修正');
    }

    const fixableCount = issues.filter(i => i.autoFixable).length;
    if (fixableCount > 0) {
      suggestions.push(`有${fixableCount}个问题支持自动修复，可点击"一键修复"快速处理`);
    }

    return suggestions;
  }

  /**
   * 生成总体评价
   */
  private generateSummary(passed: boolean, score: number, stats: ReviewStatistics): string {
    if (passed && score >= 90) {
      return `审核通过，总体质量优秀（${score}分）。仅有少量改进建议。`;
    } else if (passed) {
      return `审核通过（${score}分），发现${stats.total}个问题，其中${stats.high}个需重点关注。`;
    } else {
      return `审核未通过（${score}分），发现${stats.total}个问题，其中${stats.high}个严重问题需修改后重新审核。`;
    }
  }
}
```

### 6.2 审核报告数据结构

```typescript
/**
 * 审核报告
 */
interface ReviewReport {
  id: string;
  documentId?: string;
  timestamp: string;
  passed: boolean;
  score: number;
  scores: Record<string, number>;
  statistics: ReviewStatistics;
  issues: ReviewIssue[];
  issuesByType: Record<string, ReviewIssue[]>;
  suggestions: string[];
  summary: string;
}

/**
 * 审核统计
 */
interface ReviewStatistics {
  total: number;
  high: number;
  medium: number;
  low: number;
  autoFixable: number;
}

/**
 * 审核问题
 */
interface ReviewIssue {
  id: string;
  ruleId: string;
  type: 'format' | 'content' | 'logic' | 'language' | 'policy';
  severity: 'high' | 'medium' | 'low';
  description: string;
  position?: { start: number; end: number };
  originalText?: string;
  suggestion: string;
  autoFixable: boolean;
  fixAction?: FixAction;
}

/**
 * 修复操作
 */
interface FixAction {
  type: 'change_font_size' | 'change_font' | 'change_line_height'
    | 'change_indent' | 'change_margin' | 'replace_text';
  target: string;
  targetIndex?: number;
  side?: string;
  position?: { start: number; end: number };
  value: any;
}
```

---

## 7. 自动修复机制

### 7.1 AutoFixer（自动修复器）

```typescript
/**
 * 自动修复器
 * 对可自动修复的格式问题执行修复操作
 */
class AutoFixer {
  /**
   * 获取可自动修复的问题列表
   */
  getFixableIssues(issues: ReviewIssue[]): ReviewIssue[] {
    return issues.filter(issue => issue.autoFixable && issue.fixAction);
  }

  /**
   * 修复单个问题
   */
  async fixIssue(issue: ReviewIssue, editor: Editor): Promise<boolean> {
    if (!issue.autoFixable || !issue.fixAction) return false;

    try {
      switch (issue.fixAction.type) {
        case 'change_font_size':
          return this.fixFontSize(editor, issue.fixAction);
        case 'change_font':
          return this.fixFont(editor, issue.fixAction);
        case 'change_line_height':
          return this.fixLineHeight(editor, issue.fixAction);
        case 'change_indent':
          return this.fixIndent(editor, issue.fixAction);
        case 'replace_text':
          return this.fixText(editor, issue.fixAction);
        case 'change_margin':
          return this.fixMargin(editor, issue.fixAction);
        default:
          return false;
      }
    } catch (error) {
      console.error('自动修复失败:', error);
      return false;
    }
  }

  /**
   * 批量修复所有可修复的问题
   */
  async fixAll(issues: ReviewIssue[], editor: Editor): Promise<FixResult> {
    const fixable = this.getFixableIssues(issues);
    let successCount = 0;
    let failCount = 0;
    const fixedIssueIds: string[] = [];

    for (const issue of fixable) {
      const success = await this.fixIssue(issue, editor);
      if (success) {
        successCount++;
        fixedIssueIds.push(issue.id);
      } else {
        failCount++;
      }
    }

    return {
      totalFixable: fixable.length,
      successCount,
      failCount,
      fixedIssueIds,
    };
  }

  private fixFontSize(editor: Editor, action: FixAction): boolean {
    if (action.target === 'heading') {
      editor.chain().selectAll().run();
      // 查找标题节点并修改字号
      const { doc } = editor.state;
      doc.descendants((node, pos) => {
        if (node.type.name === 'heading') {
          editor.chain()
            .setNodeSelection(pos)
            .updateAttributes('heading', { fontSize: `${action.value}pt` })
            .run();
        }
      });
    } else if (action.target === 'paragraph' && action.targetIndex !== undefined) {
      // 修改指定段落的字号
      let paragraphIndex = 0;
      const { doc } = editor.state;
      doc.descendants((node, pos) => {
        if (node.type.name === 'paragraph') {
          if (paragraphIndex === action.targetIndex) {
            editor.chain()
              .setNodeSelection(pos)
              .updateAttributes('paragraph', { fontSize: `${action.value}pt` })
              .run();
          }
          paragraphIndex++;
        }
      });
    }
    return true;
  }

  private fixFont(editor: Editor, action: FixAction): boolean {
    const { doc } = editor.state;
    doc.descendants((node, pos) => {
      if (node.type.name === 'heading') {
        editor.chain()
          .setNodeSelection(pos)
          .updateAttributes('heading', { fontFamily: action.value })
          .run();
      }
    });
    return true;
  }

  private fixLineHeight(editor: Editor, action: FixAction): boolean {
    // 类似fixFontSize的逻辑
    return true;
  }

  private fixIndent(editor: Editor, action: FixAction): boolean {
    // 修改段落缩进
    return true;
  }

  private fixText(editor: Editor, action: FixAction): boolean {
    if (action.position) {
      editor.chain()
        .setTextSelection(action.position)
        .deleteSelection()
        .insertContent(action.value)
        .run();
      return true;
    }
    return false;
  }

  private fixMargin(editor: Editor, action: FixAction): boolean {
    // 页边距修改需通过文档元数据更新
    return true;
  }
}

/**
 * 修复结果
 */
interface FixResult {
  totalFixable: number;
  successCount: number;
  failCount: number;
  fixedIssueIds: string[];
}
```

---

## 8. 接口设计

### 8.1 对外接口

```typescript
/**
 * 审核服务对外接口（React Hook 形式）
 */
interface UseReview {
  /** 审核状态 */
  isReviewing: boolean;
  /** 最近的审核报告 */
  lastReport: ReviewReport | null;

  /** 执行完整审核 */
  review: (request: ReviewRequest) => Promise<ReviewReport>;
  /** 仅审核内容 */
  reviewContent: (content: string, docType: DocType) => Promise<ReviewReport>;
  /** 仅审核格式 */
  reviewFormat: (formatInfo: DocumentFormatInfo, docType: DocType) => Promise<ReviewReport>;
  /** 获取可修复问题 */
  getFixableIssues: () => ReviewIssue[];
  /** 修复单个问题 */
  fixIssue: (issue: ReviewIssue) => Promise<boolean>;
  /** 一键修复所有 */
  fixAll: () => Promise<FixResult>;
  /** 获取审核历史 */
  getHistory: (documentId: string) => Promise<ReviewReport[]>;
}

/**
 * 审核请求
 */
interface ReviewRequest {
  documentId?: string;
  content: string;
  formatInfo?: DocumentFormatInfo;
  docType: DocType;
  reviewTypes: ('content' | 'format' | 'all')[];
  customRules?: string[];
}
```

### 8.2 IPC接口

```typescript
/**
 * 审核相关IPC通道
 */
interface AuditIPC {
  /** 保存审核记录 */
  'audit:create': (record: CreateAuditRecord) => Promise<void>;
  /** 获取文档的审核历史 */
  'audit:history': (documentId: string) => Promise<AuditRecord[]>;
  /** 获取最近的审核记录 */
  'audit:latest': (documentId: string) => Promise<AuditRecord | null>;
}
```

---

## 9. 异常处理设计

### 9.1 异常类型

```typescript
/**
 * 审核错误
 */
class ReviewError extends Error {
  constructor(
    message: string,
    public readonly code: ReviewErrorCode,
    public readonly details?: Record<string, any>
  ) {
    super(message);
    this.name = 'ReviewError';
  }
}

enum ReviewErrorCode {
  AI_REVIEW_FAILED = 'AI_REVIEW_FAILED',
  AI_RESPONSE_PARSE_FAILED = 'AI_RESPONSE_PARSE_FAILED',
  FORMAT_INFO_MISSING = 'FORMAT_INFO_MISSING',
  DOCUMENT_TOO_LONG = 'DOCUMENT_TOO_LONG',
  RULE_EXECUTION_FAILED = 'RULE_EXECUTION_FAILED',
  AUTO_FIX_FAILED = 'AUTO_FIX_FAILED',
  SAVE_RECORD_FAILED = 'SAVE_RECORD_FAILED',
}
```

### 9.2 异常处理策略

| 异常类型 | 处理策略 | 用户提示 |
|----------|----------|----------|
| AI_REVIEW_FAILED | 委托AI模块重试，最终失败则仅返回本地检查结果 | "AI内容审核暂时不可用，已返回本地格式检查结果" |
| AI_RESPONSE_PARSE_FAILED | 重试一次，失败则返回部分结果 | "AI审核结果解析异常，部分审核项可能缺失" |
| DOCUMENT_TOO_LONG | 分段审核或提示用户 | "文档内容过长，将分段进行审核" |
| AUTO_FIX_FAILED | 跳过该问题，标记为手动修复 | "部分问题自动修复失败，请手动修改" |

---

## 10. 附录

### 10.1 审核项清单

| 审核项 | 类型 | 依赖AI | 可自动修复 | 严重级别 |
|--------|------|--------|------------|----------|
| 标题字号 | format | 否 | 是 | 高 |
| 标题字体 | format | 否 | 是 | 高 |
| 正文字号 | format | 否 | 是 | 高 |
| 正文字体 | format | 否 | 是 | 高 |
| 行距 | format | 否 | 是 | 中 |
| 首行缩进 | format | 否 | 是 | 中 |
| 页边距 | format | 否 | 是 | 高 |
| 序号格式 | format | 否 | 否 | 中 |
| 标点符号 | language | 否 | 是 | 低 |
| 敏感词 | language | 否 | 否 | 高 |
| 重复内容 | content | 否 | 否 | 低 |
| 逻辑检查 | logic | 是 | 否 | 中 |
| 事实核查 | content | 是 | 否 | 高 |
| 政策合规 | policy | 是 | 否 | 高 |
| 用语规范 | language | 是 | 否 | 中 |

### 10.2 评分标准

| 分数段 | 等级 | 说明 |
|--------|------|------|
| 90-100 | 优秀 | 格式规范，内容质量高，可直接使用 |
| 80-89 | 良好 | 存在少量问题，修改后可使用 |
| 70-79 | 合格 | 有一定问题需要修改 |
| 60-69 | 需改进 | 存在较多问题，需重点修改 |
| 0-59 | 不合格 | 需大幅修改后重新审核 |

---

*文档结束*
