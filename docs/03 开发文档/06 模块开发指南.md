# 模块开发指南

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档版本 | V1.0 |
| 文档状态 | 已完成 |
| 创建日期 | 2026-02-28 |
| 最后更新 | 2026-02-28 |

---

## 1. 模块概览

### 1.1 核心模块结构

```
src/
├── modules/
│   ├── document/          # 文档管理模块
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── services/
│   │   ├── stores/
│   │   ├── types/
│   │   └── index.ts
│   ├── editor/            # 编辑器模块
│   ├── ai/                # AI 集成模块
│   ├── template/          # 模板管理模块
│   ├── chart/             # 图表绘制模块
│   ├── export/            # 导出模块
│   └── settings/          # 设置模块
├── shared/                # 共享代码
│   ├── components/        # 通用组件
│   ├── hooks/             # 通用 Hooks
│   ├── utils/             # 工具函数
│   └── types/             # 公共类型
└── app/                   # 应用层
    ├── layout/
    ├── routes/
    └── providers/
```

### 1.2 模块依赖关系

```
┌─────────────────────────────────────────────────────────────────────┐
│                         模块依赖关系                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                        ┌─────────────┐                              │
│                        │   app       │                              │
│                        └──────┬──────┘                              │
│                               │                                      │
│       ┌───────────────────────┼───────────────────────┐             │
│       │           │           │           │           │             │
│       ▼           ▼           ▼           ▼           ▼             │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐       │
│  │document │ │ editor  │ │   ai    │ │ chart   │ │settings │       │
│  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘       │
│       │           │           │           │           │             │
│       └───────────┴───────────┼───────────┴───────────┘             │
│                               │                                      │
│                               ▼                                      │
│                        ┌─────────────┐                              │
│                        │   shared    │                              │
│                        └─────────────┘                              │
│                                                                     │
│  规则: 模块只能依赖 shared 和同级模块，不能相互循环依赖              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. 文档管理模块 (document)

### 2.1 模块结构

```
modules/document/
├── components/
│   ├── DocumentList.tsx       # 文档列表
│   ├── DocumentCard.tsx       # 文档卡片
│   ├── DocumentItem.tsx       # 文档列表项
│   └── DocumentFilters.tsx    # 筛选器
├── hooks/
│   ├── useDocument.ts         # 单文档操作
│   ├── useDocuments.ts        # 文档列表
│   └── useDocumentSearch.ts   # 文档搜索
├── services/
│   └── documentService.ts     # 文档服务
├── stores/
│   └── documentStore.ts       # 文档状态
├── types/
│   └── document.types.ts      # 类型定义
└── index.ts                   # 模块导出
```

### 2.2 类型定义

```typescript
// types/document.types.ts

export interface Document {
  id: string;
  title: string;
  content: DocumentContent | null;
  contentText: string | null;
  docType: DocumentType;
  templateId: string | null;
  status: DocumentStatus;
  environment: Environment;
  wordCount: number;
  tags: string[];
  metadata: Record<string, unknown>;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

export type DocumentType = 
  | 'notice' 
  | 'report' 
  | 'request' 
  | 'reply' 
  | 'letter' 
  | 'minutes' 
  | 'other';

export type DocumentStatus = 'draft' | 'reviewing' | 'final' | 'archived';

export type Environment = 'public' | 'private';

export interface DocumentContent {
  version: string;
  blocks: ContentBlock[];
  meta: DocumentMeta;
}
```

### 2.3 Store 实现

```typescript
// stores/documentStore.ts

import { create } from 'zustand';
import { documentService } from '../services/documentService';
import type { Document, DocumentStatus } from '../types/document.types';

interface DocumentState {
  // 状态
  documents: Document[];
  currentDocument: Document | null;
  isLoading: boolean;
  error: Error | null;
  filters: DocumentFilters;
}

interface DocumentActions {
  // 查询
  loadDocuments: () => Promise<void>;
  loadDocument: (id: string) => Promise<void>;
  
  // 操作
  createDocument: (params: CreateDocumentParams) => Promise<Document>;
  updateDocument: (id: string, updates: Partial<Document>) => Promise<void>;
  deleteDocument: (id: string) => Promise<void>;
  
  // 状态
  setCurrentDocument: (doc: Document | null) => void;
  setFilters: (filters: Partial<DocumentFilters>) => void;
  clearError: () => void;
}

type DocumentStore = DocumentState & DocumentActions;

export const useDocumentStore = create<DocumentStore>((set, get) => ({
  // 初始状态
  documents: [],
  currentDocument: null,
  isLoading: false,
  error: null,
  filters: {},

  // 加载文档列表
  loadDocuments: async () => {
    set({ isLoading: true, error: null });
    try {
      const { filters } = get();
      const response = await documentService.getDocuments(filters);
      set({ documents: response.items, isLoading: false });
    } catch (error) {
      set({ error: error as Error, isLoading: false });
    }
  },

  // 加载单个文档
  loadDocument: async (id: string) => {
    set({ isLoading: true, error: null });
    try {
      const document = await documentService.getDocument(id);
      set({ currentDocument: document, isLoading: false });
    } catch (error) {
      set({ error: error as Error, isLoading: false });
    }
  },

  // 创建文档
  createDocument: async (params) => {
    const document = await documentService.createDocument(params);
    set(state => ({
      documents: [document, ...state.documents],
      currentDocument: document,
    }));
    return document;
  },

  // 更新文档
  updateDocument: async (id, updates) => {
    await documentService.updateDocument(id, updates);
    set(state => ({
      documents: state.documents.map(doc =>
        doc.id === id ? { ...doc, ...updates } : doc
      ),
      currentDocument: state.currentDocument?.id === id
        ? { ...state.currentDocument, ...updates }
        : state.currentDocument,
    }));
  },

  // 删除文档
  deleteDocument: async (id) => {
    await documentService.deleteDocument(id);
    set(state => ({
      documents: state.documents.filter(doc => doc.id !== id),
      currentDocument: state.currentDocument?.id === id
        ? null
        : state.currentDocument,
    }));
  },

  // 设置当前文档
  setCurrentDocument: (doc) => set({ currentDocument: doc }),

  // 设置筛选条件
  setFilters: (filters) => set(state => ({
    filters: { ...state.filters, ...filters },
  })),

  // 清除错误
  clearError: () => set({ error: null }),
}));
```

### 2.4 Service 实现

```typescript
// services/documentService.ts

import { invoke } from '@tauri-apps/api/core';
import type { 
  Document, 
  DocumentFilters,
  CreateDocumentParams,
} from '../types/document.types';

export const documentService = {
  // 获取文档列表
  async getDocuments(filters?: DocumentFilters) {
    const response = await invoke<ApiResponse<GetDocumentsResponse>>(
      'get_documents',
      { params: filters }
    );
    
    if (!response.success) {
      throw new Error(response.error.message);
    }
    
    return response.data;
  },

  // 获取单个文档
  async getDocument(id: string) {
    const response = await invoke<ApiResponse<{ document: Document }>>(
      'get_document',
      { params: { id } }
    );
    
    if (!response.success) {
      throw new Error(response.error.message);
    }
    
    return response.data.document;
  },

  // 创建文档
  async createDocument(params: CreateDocumentParams) {
    const response = await invoke<ApiResponse<{ document: Document }>>(
      'create_document',
      { params }
    );
    
    if (!response.success) {
      throw new Error(response.error.message);
    }
    
    return response.data.document;
  },

  // 更新文档
  async updateDocument(id: string, updates: Partial<Document>) {
    const response = await invoke<ApiResponse<{ document: Document }>>(
      'update_document',
      { params: { id, ...updates } }
    );
    
    if (!response.success) {
      throw new Error(response.error.message);
    }
    
    return response.data.document;
  },

  // 删除文档
  async deleteDocument(id: string, permanent = false) {
    const response = await invoke<ApiResponse<{ success: boolean }>>(
      'delete_document',
      { params: { id, permanent } }
    );
    
    if (!response.success) {
      throw new Error(response.error.message);
    }
  },

  // 导出文档
  async exportDocument(id: string, format: ExportFormat, options?: ExportOptions) {
    const response = await invoke<ApiResponse<ExportResponse>>(
      'export_document',
      { params: { id, format, ...options } }
    );
    
    if (!response.success) {
      throw new Error(response.error.message);
    }
    
    return response.data;
  },
};
```

---

## 3. AI 集成模块 (ai)

### 3.1 模块结构

```
modules/ai/
├── components/
│   ├── AIPanel.tsx            # AI 面板容器
│   ├── AIGenerate.tsx         # 生成功能
│   ├── AIReview.tsx           # 审核功能
│   ├── AIRewrite.tsx          # 改写功能
│   ├── AIChat.tsx             # 对话功能
│   └── AIStatusBar.tsx        # AI 状态栏
├── hooks/
│   ├── useAI.ts               # AI 操作 Hook
│   ├── useAIStream.ts         # 流式输出 Hook
│   └── useAIConfig.ts         # AI 配置 Hook
├── services/
│   ├── aiService.ts           # AI 服务
│   └── adapters/              # AI 适配器
│       ├── baseAdapter.ts
│       ├── ollamaAdapter.ts
│       ├── openaiAdapter.ts
│       └── index.ts
├── stores/
│   └── aiStore.ts             # AI 状态
├── types/
│   └── ai.types.ts            # 类型定义
└── index.ts
```

### 3.2 流式输出 Hook

```typescript
// hooks/useAIStream.ts

import { useState, useCallback, useRef } from 'react';
import { listen } from '@tauri-apps/api/event';
import { invoke } from '@tauri-apps/api/core';

interface UseAIStreamOptions {
  onChunk?: (chunk: string) => void;
  onComplete?: (fullContent: string) => void;
  onError?: (error: Error) => void;
}

export function useAIStream(options: UseAIStreamOptions = {}) {
  const [content, setContent] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const contentRef = useRef('');
  const unlistenRef = useRef<(() => void)[]>([]);

  const startStream = useCallback(async (params: AIGenerateParams) => {
    // 重置状态
    setContent('');
    setError(null);
    setIsStreaming(true);
    contentRef.current = '';

    try {
      // 设置事件监听
      const unlistenChunk = await listen<string>('ai-stream-chunk', (event) => {
        contentRef.current += event.payload;
        setContent(contentRef.current);
        options.onChunk?.(event.payload);
      });

      const unlistenComplete = await listen('ai-stream-complete', () => {
        setIsStreaming(false);
        options.onComplete?.(contentRef.current);
      });

      const unlistenError = await listen<string>('ai-stream-error', (event) => {
        const err = new Error(event.payload);
        setError(err);
        setIsStreaming(false);
        options.onError?.(err);
      });

      unlistenRef.current = [unlistenChunk, unlistenComplete, unlistenError];

      // 发起请求
      await invoke('ai_generate_stream', { params });

    } catch (err) {
      const error = err as Error;
      setError(error);
      setIsStreaming(false);
      options.onError?.(error);
    }
  }, [options]);

  const stopStream = useCallback(() => {
    // 取消监听
    unlistenRef.current.forEach(unlisten => unlisten());
    unlistenRef.current = [];
    
    // 发送停止命令
    invoke('ai_stop_stream').catch(console.error);
    
    setIsStreaming(false);
  }, []);

  const reset = useCallback(() => {
    setContent('');
    setError(null);
    contentRef.current = '';
  }, []);

  return {
    content,
    isStreaming,
    error,
    startStream,
    stopStream,
    reset,
  };
}
```

### 3.3 AI 面板组件

```typescript
// components/AIPanel.tsx

import { useState } from 'react';
import { Tabs } from 'antd';
import { AIGenerate } from './AIGenerate';
import { AIReview } from './AIReview';
import { AIRewrite } from './AIRewrite';
import { AIChat } from './AIChat';
import { AIStatusBar } from './AIStatusBar';
import { useEnvironmentStore } from '@/shared/stores/environmentStore';

export function AIPanel() {
  const [activeTab, setActiveTab] = useState('generate');
  const { environment } = useEnvironmentStore();

  const items = [
    { key: 'generate', label: '生成', children: <AIGenerate /> },
    { key: 'review', label: '审核', children: <AIReview /> },
    { key: 'rewrite', label: '改写', children: <AIRewrite /> },
    { key: 'chat', label: '对话', children: <AIChat /> },
  ];

  return (
    <div className="flex flex-col h-full border-l border-gray-200">
      <div className="px-4 py-3 border-b border-gray-200">
        <h3 className="text-base font-medium">AI 助手</h3>
      </div>

      <div className="flex-1 overflow-hidden">
        <Tabs
          activeKey={activeTab}
          onChange={setActiveTab}
          items={items}
          className="h-full"
        />
      </div>

      <AIStatusBar environment={environment} />
    </div>
  );
}
```

---

## 4. 编辑器模块 (editor)

### 4.1 模块结构

```
modules/editor/
├── components/
│   ├── Editor.tsx             # 编辑器主组件
│   ├── Toolbar.tsx            # 工具栏
│   ├── ContentArea.tsx        # 内容区域
│   ├── FloatingToolbar.tsx    # 浮动工具栏
│   └── StatusBar.tsx          # 状态栏
├── hooks/
│   ├── useEditor.ts           # 编辑器操作
│   ├── useEditorHistory.ts    # 历史记录
│   └── useAutoSave.ts         # 自动保存
├── plugins/                   # 编辑器插件
│   ├── formatPlugin.ts        # 格式化插件
│   ├── shortcutPlugin.ts      # 快捷键插件
│   └── aiPlugin.ts            # AI 插件
├── stores/
│   └── editorStore.ts         # 编辑器状态
├── types/
│   └── editor.types.ts
└── index.ts
```

### 4.2 自动保存 Hook

```typescript
// hooks/useAutoSave.ts

import { useEffect, useRef, useCallback } from 'react';
import { debounce } from 'lodash-es';
import { useDocumentStore } from '@/modules/document';
import { useSettingsStore } from '@/modules/settings';

interface UseAutoSaveOptions {
  documentId: string;
  content: DocumentContent;
  enabled?: boolean;
}

export function useAutoSave({ 
  documentId, 
  content, 
  enabled = true 
}: UseAutoSaveOptions) {
  const { updateDocument } = useDocumentStore();
  const { settings } = useSettingsStore();
  const lastSavedRef = useRef<string>('');
  const isSavingRef = useRef(false);

  // 获取自动保存间隔 (毫秒)
  const interval = settings.autoSaveInterval ?? 30000;

  // 保存函数
  const save = useCallback(async () => {
    if (isSavingRef.current) return;
    
    const contentStr = JSON.stringify(content);
    if (contentStr === lastSavedRef.current) return;

    isSavingRef.current = true;
    try {
      await updateDocument(documentId, { content });
      lastSavedRef.current = contentStr;
    } finally {
      isSavingRef.current = false;
    }
  }, [documentId, content, updateDocument]);

  // 防抖保存
  const debouncedSave = useMemo(
    () => debounce(save, interval),
    [save, interval]
  );

  // 内容变化时触发保存
  useEffect(() => {
    if (!enabled) return;
    debouncedSave();
    
    return () => {
      debouncedSave.cancel();
    };
  }, [content, debouncedSave, enabled]);

  // 组件卸载时立即保存
  useEffect(() => {
    return () => {
      debouncedSave.flush();
    };
  }, [debouncedSave]);

  return {
    save,
    isSaving: isSavingRef.current,
  };
}
```

---

## 5. 环境管理模块 (environment)

### 5.1 环境 Store

```typescript
// shared/stores/environmentStore.ts

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { invoke } from '@tauri-apps/api/core';

type Environment = 'public' | 'private';

interface EnvironmentState {
  environment: Environment;
  isTransitioning: boolean;
}

interface EnvironmentActions {
  switchEnvironment: (target: Environment) => Promise<boolean>;
  initialize: () => Promise<void>;
}

type EnvironmentStore = EnvironmentState & EnvironmentActions;

export const useEnvironmentStore = create<EnvironmentStore>()(
  persist(
    (set, get) => ({
      environment: 'private',
      isTransitioning: false,

      switchEnvironment: async (target) => {
        const { environment } = get();
        if (environment === target) return true;

        set({ isTransitioning: true });

        try {
          const response = await invoke<ApiResponse<SwitchEnvResponse>>(
            'switch_environment',
            { params: { target } }
          );

          if (response.success) {
            set({ 
              environment: target,
              isTransitioning: false,
            });
            return true;
          } else {
            set({ isTransitioning: false });
            return false;
          }
        } catch (error) {
          set({ isTransitioning: false });
          throw error;
        }
      },

      initialize: async () => {
        const response = await invoke<ApiResponse<GetEnvResponse>>(
          'get_current_environment'
        );
        
        if (response.success) {
          set({ environment: response.data.environment });
        }
      },
    }),
    {
      name: 'environment-storage',
      partialize: (state) => ({ environment: state.environment }),
    }
  )
);
```

### 5.2 环境切换组件

```typescript
// shared/components/EnvironmentSwitch.tsx

import { useState } from 'react';
import { Modal, Button, message } from 'antd';
import { CloudOutlined, SafetyOutlined } from '@ant-design/icons';
import { useEnvironmentStore } from '../stores/environmentStore';

export function EnvironmentSwitch() {
  const { environment, switchEnvironment, isTransitioning } = useEnvironmentStore();
  const [showConfirm, setShowConfirm] = useState(false);

  const targetEnv = environment === 'private' ? 'public' : 'private';

  const handleSwitch = async () => {
    // 私域→公网需要确认
    if (environment === 'private') {
      setShowConfirm(true);
      return;
    }

    // 公网→私域直接切换
    const success = await switchEnvironment('private');
    if (success) {
      message.success('已切换到私域环境');
    }
  };

  const confirmSwitch = async () => {
    setShowConfirm(false);
    const success = await switchEnvironment('public');
    if (success) {
      message.info('已切换到公网环境');
    }
  };

  return (
    <>
      <Button
        type="text"
        loading={isTransitioning}
        onClick={handleSwitch}
        icon={targetEnv === 'public' ? <CloudOutlined /> : <SafetyOutlined />}
      >
        切换到{targetEnv === 'public' ? '公网' : '私域'}
      </Button>

      <Modal
        title="切换到公网环境"
        open={showConfirm}
        onOk={confirmSwitch}
        onCancel={() => setShowConfirm(false)}
        okText="我已了解，继续切换"
        cancelText="取消"
      >
        <div className="space-y-2">
          <p>您正在从私域环境切换到公网环境，请注意：</p>
          <ul className="list-disc pl-5 space-y-1">
            <li>公网环境下，输入内容将发送至云端 AI 服务</li>
            <li>请确保文档不包含敏感信息</li>
          </ul>
        </div>
      </Modal>
    </>
  );
}
```

---

## 6. 新建模块指南

### 6.1 创建步骤

1. **创建目录结构**
```bash
mkdir -p src/modules/new-module/{components,hooks,services,stores,types}
```

2. **定义类型** (types/xxx.types.ts)
3. **实现服务** (services/xxxService.ts)
4. **创建 Store** (stores/xxxStore.ts)
5. **开发组件** (components/Xxx.tsx)
6. **导出模块** (index.ts)

### 6.2 模块导出规范

```typescript
// index.ts

// 导出组件
export { DocumentList } from './components/DocumentList';
export { DocumentCard } from './components/DocumentCard';

// 导出 Hooks
export { useDocument } from './hooks/useDocument';
export { useDocuments } from './hooks/useDocuments';

// 导出 Store
export { useDocumentStore } from './stores/documentStore';

// 导出类型
export type { 
  Document, 
  DocumentType,
  DocumentStatus,
} from './types/document.types';
```

### 6.3 跨模块通信

```typescript
// 使用事件总线
import { emit, listen } from '@tauri-apps/api/event';

// 发送事件
await emit('document-saved', { id: 'xxx' });

// 监听事件
const unlisten = await listen('document-saved', (event) => {
  console.log('Document saved:', event.payload);
});
```

---

*文档结束*
