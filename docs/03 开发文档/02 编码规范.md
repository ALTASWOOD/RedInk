# 编码规范

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档版本 | V1.0 |
| 文档状态 | 已完成 |
| 创建日期 | 2026-02-28 |
| 最后更新 | 2026-02-28 |

---

## 1. 通用规范

### 1.1 文件命名

| 类型 | 命名规则 | 示例 |
|------|----------|------|
| 组件文件 | PascalCase | `DocumentEditor.tsx` |
| Hook文件 | camelCase，use前缀 | `useDocument.ts` |
| 工具文件 | camelCase | `formatDate.ts` |
| 类型文件 | camelCase | `document.types.ts` |
| 样式文件 | kebab-case | `document-editor.css` |
| 常量文件 | camelCase | `constants.ts` |
| 测试文件 | 同源文件+.test | `DocumentEditor.test.tsx` |

### 1.2 目录命名

- 使用 **kebab-case** 或全小写
- 语义明确，避免缩写

```
✅ 正确
src/components/document-editor/
src/services/ai/

❌ 错误
src/components/DocEditor/
src/services/AI/
```

### 1.3 代码格式化

项目使用 Prettier 统一格式化:

```json
// .prettierrc
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100,
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "endOfLine": "lf"
}
```

---

## 2. TypeScript 规范

### 2.1 类型定义

```typescript
// ✅ 优先使用 interface 定义对象类型
interface Document {
  id: string;
  title: string;
  content: DocumentContent;
  createdAt: Date;
}

// ✅ 使用 type 定义联合类型、交叉类型
type DocumentStatus = 'draft' | 'reviewing' | 'final' | 'archived';
type Environment = 'public' | 'private';

// ✅ 明确导出类型
export interface DocumentProps {
  document: Document;
  onSave: (doc: Document) => void;
}

// ❌ 避免使用 any
const data: any = {}; // 禁止

// ✅ 使用 unknown 替代 any，然后类型守卫
const data: unknown = {};
if (isDocument(data)) {
  // data 现在是 Document 类型
}
```

### 2.2 类型守卫

```typescript
// 自定义类型守卫
function isDocument(value: unknown): value is Document {
  return (
    typeof value === 'object' &&
    value !== null &&
    'id' in value &&
    'title' in value
  );
}

// 使用 in 操作符
function processResult(result: SuccessResult | ErrorResult) {
  if ('error' in result) {
    console.error(result.error);
  } else {
    console.log(result.data);
  }
}
```

### 2.3 泛型使用

```typescript
// ✅ 合理使用泛型
interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
}

// ✅ 泛型约束
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

// ✅ 默认泛型参数
interface PaginatedList<T = unknown> {
  items: T[];
  total: number;
  page: number;
  pageSize: number;
}
```

### 2.4 枚举使用

```typescript
// ✅ 使用 const enum 或 as const
const DocumentStatus = {
  DRAFT: 'draft',
  REVIEWING: 'reviewing',
  FINAL: 'final',
  ARCHIVED: 'archived',
} as const;

type DocumentStatus = typeof DocumentStatus[keyof typeof DocumentStatus];

// ✅ 或使用 enum (会生成运行时代码)
enum Environment {
  PUBLIC = 'public',
  PRIVATE = 'private',
}
```

---

## 3. React 规范

### 3.1 组件定义

```typescript
// ✅ 使用函数组件 + TypeScript
interface DocumentEditorProps {
  document: Document;
  readonly?: boolean;
  onSave: (doc: Document) => void;
  onCancel?: () => void;
}

export function DocumentEditor({ 
  document, 
  readonly = false,
  onSave,
  onCancel 
}: DocumentEditorProps) {
  // 组件逻辑
  return <div>...</div>;
}

// ✅ 使用 React.FC 时需显式声明 children (React 18+)
interface LayoutProps {
  children: React.ReactNode;
  title?: string;
}

export const Layout: React.FC<LayoutProps> = ({ children, title }) => {
  return <div>{children}</div>;
};
```

### 3.2 Hooks 规范

```typescript
// ✅ 自定义 Hook 必须以 use 开头
function useDocument(id: string) {
  const [document, setDocument] = useState<Document | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    loadDocument(id)
      .then(setDocument)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [id]);

  return { document, loading, error };
}

// ✅ Hook 返回对象而非数组 (当返回值 > 2 个时)
function useForm<T>(initialValues: T) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  return {
    values,
    errors,
    isSubmitting,
    setFieldValue: (field: keyof T, value: T[keyof T]) => {...},
    handleSubmit: (onSubmit: (values: T) => void) => {...},
    reset: () => setValues(initialValues),
  };
}
```

### 3.3 事件处理

```typescript
// ✅ 事件处理函数命名以 handle 开头
function DocumentEditor() {
  const handleSave = useCallback(() => {
    // 保存逻辑
  }, []);

  const handleTitleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setTitle(e.target.value);
  }, []);

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && e.ctrlKey) {
      handleSave();
    }
  }, [handleSave]);

  return (
    <input 
      onChange={handleTitleChange}
      onKeyDown={handleKeyDown}
    />
  );
}
```

### 3.4 条件渲染

```typescript
// ✅ 简单条件使用 &&
{isLoading && <Spinner />}

// ✅ 二元条件使用三元运算符
{isError ? <ErrorMessage /> : <Content />}

// ✅ 多条件使用早返回或 switch
function StatusBadge({ status }: { status: DocumentStatus }) {
  switch (status) {
    case 'draft':
      return <Badge color="gray">草稿</Badge>;
    case 'reviewing':
      return <Badge color="blue">审核中</Badge>;
    case 'final':
      return <Badge color="green">定稿</Badge>;
    default:
      return null;
  }
}

// ❌ 避免过深的嵌套条件
```

### 3.5 列表渲染

```typescript
// ✅ 使用稳定且唯一的 key
{documents.map(doc => (
  <DocumentItem key={doc.id} document={doc} />
))}

// ❌ 避免使用索引作为 key (除非列表静态不变)
{items.map((item, index) => (
  <Item key={index} item={item} /> // 不推荐
))}
```

---

## 4. 状态管理规范 (Zustand)

### 4.1 Store 定义

```typescript
// ✅ 定义 Store 接口
interface DocumentStore {
  // 状态
  documents: Document[];
  currentDocument: Document | null;
  isLoading: boolean;
  error: Error | null;
  
  // 动作
  loadDocuments: () => Promise<void>;
  selectDocument: (id: string) => void;
  createDocument: (doc: Partial<Document>) => Promise<Document>;
  updateDocument: (id: string, updates: Partial<Document>) => Promise<void>;
  deleteDocument: (id: string) => Promise<void>;
}

// ✅ 创建 Store
export const useDocumentStore = create<DocumentStore>((set, get) => ({
  documents: [],
  currentDocument: null,
  isLoading: false,
  error: null,

  loadDocuments: async () => {
    set({ isLoading: true, error: null });
    try {
      const documents = await documentService.getAll();
      set({ documents, isLoading: false });
    } catch (error) {
      set({ error: error as Error, isLoading: false });
    }
  },

  selectDocument: (id) => {
    const document = get().documents.find(d => d.id === id) ?? null;
    set({ currentDocument: document });
  },

  // ... 其他动作
}));
```

### 4.2 Store 拆分

```typescript
// ✅ 按功能拆分 Store
// stores/documentStore.ts - 文档相关
// stores/aiStore.ts - AI 相关
// stores/uiStore.ts - UI 状态
// stores/settingsStore.ts - 设置

// ✅ 使用 slice 模式组合
interface AppStore extends DocumentSlice, AISlice, UISlice {}

const useAppStore = create<AppStore>()((...args) => ({
  ...createDocumentSlice(...args),
  ...createAISlice(...args),
  ...createUISlice(...args),
}));
```

### 4.3 选择器优化

```typescript
// ✅ 使用选择器避免不必要的重渲染
const documents = useDocumentStore(state => state.documents);
const loadDocuments = useDocumentStore(state => state.loadDocuments);

// ✅ 使用 shallow 比较
import { shallow } from 'zustand/shallow';

const { documents, isLoading } = useDocumentStore(
  state => ({ documents: state.documents, isLoading: state.isLoading }),
  shallow
);

// ❌ 避免订阅整个 store
const store = useDocumentStore(); // 任何状态变化都会触发重渲染
```

---

## 5. 样式规范 (Tailwind CSS)

### 5.1 类名顺序

遵循以下顺序:

1. 布局 (display, position, flex, grid)
2. 盒模型 (width, height, margin, padding)
3. 排版 (font, text)
4. 视觉 (background, border, shadow)
5. 交互 (hover, focus, transition)

```tsx
// ✅ 正确顺序
<div className="
  flex items-center justify-between
  w-full h-12 px-4
  text-sm font-medium text-gray-700
  bg-white border border-gray-200 rounded-lg shadow-sm
  hover:bg-gray-50 transition-colors
">

// 使用 Prettier Tailwind 插件自动排序
```

### 5.2 响应式设计

```tsx
// ✅ 移动优先原则
<div className="
  flex flex-col          // 移动端默认
  md:flex-row            // 中等屏幕及以上
  lg:gap-8               // 大屏幕
">

// ✅ 环境主题色使用 CSS 变量
<div className="bg-env-primary text-env-primary-foreground">
```

### 5.3 组件样式

```tsx
// ✅ 使用 cva 管理变体
import { cva } from 'class-variance-authority';

const buttonVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input bg-background hover:bg-accent',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);
```

---

## 6. 注释规范

### 6.1 文件头注释

```typescript
/**
 * @file DocumentEditor.tsx
 * @description 公文编辑器组件，提供富文本编辑、格式化和预览功能
 * @author RedInk Team
 * @created 2026-02-28
 */
```

### 6.2 函数注释

```typescript
/**
 * 生成公文内容
 * @param type - 公文类型
 * @param keyPoints - 关键要点列表
 * @param options - 生成选项
 * @returns 生成的公文内容
 * @throws {AIServiceError} 当AI服务不可用时抛出
 * @example
 * ```ts
 * const content = await generateDocument('notice', ['会议通知', '3月15日']);
 * ```
 */
async function generateDocument(
  type: DocumentType,
  keyPoints: string[],
  options?: GenerateOptions
): Promise<string> {
  // ...
}
```

### 6.3 行内注释

```typescript
// ✅ 解释"为什么"，而不是"是什么"
// 需要延迟200ms再显示工具栏，避免误触
setTimeout(() => setVisible(true), 200);

// ✅ TODO/FIXME 注释
// TODO: 添加错误重试机制
// FIXME: 在Safari下存在兼容性问题
// HACK: 临时解决方案，待重构
```

---

## 7. 错误处理规范

### 7.1 错误类定义

```typescript
// ✅ 自定义错误类
export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'AppError';
  }
}

export class AIServiceError extends AppError {
  constructor(message: string, details?: Record<string, unknown>) {
    super(message, 'AI_SERVICE_ERROR', details);
    this.name = 'AIServiceError';
  }
}

export class NetworkError extends AppError {
  constructor(message: string, details?: Record<string, unknown>) {
    super(message, 'NETWORK_ERROR', details);
    this.name = 'NetworkError';
  }
}
```

### 7.2 错误边界

```typescript
// ✅ 使用 ErrorBoundary 包裹可能出错的组件
import { ErrorBoundary } from 'react-error-boundary';

function App() {
  return (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      onError={(error, info) => {
        console.error('Error caught:', error);
        // 上报错误
      }}
      onReset={() => {
        // 重置应用状态
      }}
    >
      <MainContent />
    </ErrorBoundary>
  );
}

function ErrorFallback({ error, resetErrorBoundary }: FallbackProps) {
  return (
    <div className="error-page">
      <h2>出错了</h2>
      <p>{error.message}</p>
      <button onClick={resetErrorBoundary}>重试</button>
    </div>
  );
}
```

### 7.3 异步错误处理

```typescript
// ✅ 使用 try-catch 处理异步错误
async function loadDocument(id: string) {
  try {
    const response = await api.getDocument(id);
    return response.data;
  } catch (error) {
    if (error instanceof NetworkError) {
      toast.error('网络连接失败，请检查网络');
    } else if (error instanceof AIServiceError) {
      toast.error('AI服务暂时不可用');
    } else {
      toast.error('加载文档失败');
      console.error('Unexpected error:', error);
    }
    throw error;
  }
}

// ✅ 在 Hook 中处理错误
function useAsyncAction<T>(action: () => Promise<T>) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const execute = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      return await action();
    } catch (e) {
      setError(e as Error);
      throw e;
    } finally {
      setLoading(false);
    }
  }, [action]);

  return { execute, loading, error };
}
```

---

## 8. Git 提交规范

### 8.1 Commit Message 格式

```
<type>(<scope>): <subject>

<body>

<footer>
```

### 8.2 Type 类型

| Type | 说明 |
|------|------|
| feat | 新功能 |
| fix | Bug修复 |
| docs | 文档更新 |
| style | 代码格式（不影响功能） |
| refactor | 重构（非新功能、非Bug修复） |
| perf | 性能优化 |
| test | 测试相关 |
| chore | 构建/工具链相关 |

### 8.3 示例

```bash
# 新功能
feat(editor): 添加AI内容生成功能

# Bug修复
fix(ai): 修复流式输出中断问题

# 文档
docs: 更新开发环境搭建指南

# 重构
refactor(store): 使用slice模式重构状态管理
```

---

*文档结束*
